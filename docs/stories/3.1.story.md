# Story 3.1: Workflow Instance Data Model

## Status
**Approved**

## Story

**As a** developer,
**I want** database schema for workflow instances and task instances,
**so that** each employee's onboarding/offboarding is tracked as a unique workflow with individual task states.

## Acceptance Criteria

1. workflow_instances table is created with columns: id (UUID), template_id (FK), employee_name, employee_email, employee_role, workflow_type (ONBOARDING/OFFBOARDING), status (INITIATED/IN_PROGRESS/BLOCKED/COMPLETED), initiated_by (FK users), initiated_at, completed_at, custom_field_values (JSONB), created_at, updated_at
2. task_instances table is created with columns: id (UUID), workflow_instance_id (FK), template_task_id (FK), task_name, assigned_user_id (FK users, nullable), assigned_role, status (NOT_STARTED/IN_PROGRESS/BLOCKED/COMPLETED), is_visible (boolean for conditional logic), due_date, completed_at, completed_by (FK users), checklist_data (JSONB), created_at, updated_at
3. workflow_state_history table is created for audit trail: id (UUID), workflow_instance_id (FK), previous_status, new_status, changed_by (FK users), changed_at, notes
4. Foreign key relationships are properly defined
5. Indexes are created on workflow_instance_id, assigned_user_id, status, due_date
6. Status enums are defined at database level for data integrity
7. Liquibase changelog includes rollback support

## Tasks / Subtasks

- [ ] **Task 1: Create workflow_status enum type** (AC: 1, 6)
  - [ ] Add Liquibase changeset to create WORKFLOW_STATUS enum with values: INITIATED, IN_PROGRESS, BLOCKED, COMPLETED
  - [ ] Reference: [Source: docs/architecture/database-schema.md#key-design-decisions - PostgreSQL ENUMs for type safety]

- [ ] **Task 2: Create task_status enum type** (AC: 2, 6)
  - [ ] Add Liquibase changeset to create TASK_STATUS enum with values: NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED
  - [ ] Reference: [Source: docs/architecture/database-schema.md#key-design-decisions - PostgreSQL ENUMs for type safety]

- [ ] **Task 3: Create workflow_instances table** (AC: 1, 4)
  - [ ] Add Liquibase changeset to create workflow_instances table with structure:
    - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
    - template_id: UUID NOT NULL (FK to workflow_templates.id)
    - employee_name: VARCHAR(255) NOT NULL
    - employee_email: VARCHAR(255) NOT NULL
    - employee_role: VARCHAR(100) NOT NULL
    - workflow_type: VARCHAR(20) NOT NULL (values: ONBOARDING, OFFBOARDING)
    - status: WORKFLOW_STATUS NOT NULL DEFAULT 'INITIATED'
    - initiated_by: UUID NOT NULL (FK to users.id)
    - initiated_at: TIMESTAMP NOT NULL DEFAULT NOW()
    - completed_at: TIMESTAMP NULL
    - custom_field_values: JSONB NULL
    - created_at: TIMESTAMP NOT NULL DEFAULT NOW()
    - updated_at: TIMESTAMP NOT NULL DEFAULT NOW()
  - [ ] Add foreign key constraint: template_id REFERENCES workflow_templates(id)
  - [ ] Add foreign key constraint: initiated_by REFERENCES users(id)
  - [ ] Reference: [Source: docs/architecture/data-models.md#workflowinstance]

- [ ] **Task 4: Create indexes on workflow_instances table** (AC: 5)
  - [ ] Create index on template_id for lookup by template
  - [ ] Create index on employee_email for searching by employee
  - [ ] Create index on status for filtering active workflows
  - [ ] Create index on initiated_at for chronological sorting
  - [ ] Create composite index on (status, initiated_at) for dashboard queries
  - [ ] Reference: [Source: docs/architecture/database-schema.md#key-design-decisions - Strategic indexes]

- [ ] **Task 5: Create task_instances table** (AC: 2, 4)
  - [ ] Add Liquibase changeset to create task_instances table with structure:
    - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
    - workflow_instance_id: UUID NOT NULL (FK to workflow_instances.id)
    - template_task_id: UUID NOT NULL (FK to template_tasks.id)
    - task_name: VARCHAR(255) NOT NULL
    - assigned_user_id: UUID NULL (FK to users.id)
    - assigned_role: USER_ROLE NOT NULL
    - status: TASK_STATUS NOT NULL DEFAULT 'NOT_STARTED'
    - is_visible: BOOLEAN NOT NULL DEFAULT TRUE
    - due_date: TIMESTAMP NULL
    - completed_at: TIMESTAMP NULL
    - completed_by: UUID NULL (FK to users.id)
    - checklist_data: JSONB NULL
    - created_at: TIMESTAMP NOT NULL DEFAULT NOW()
    - updated_at: TIMESTAMP NOT NULL DEFAULT NOW()
  - [ ] Add foreign key constraint: workflow_instance_id REFERENCES workflow_instances(id) ON DELETE CASCADE
  - [ ] Add foreign key constraint: template_task_id REFERENCES template_tasks(id)
  - [ ] Add foreign key constraint: assigned_user_id REFERENCES users(id) SET NULL
  - [ ] Add foreign key constraint: completed_by REFERENCES users(id) SET NULL
  - [ ] Reference: [Source: docs/architecture/data-models.md#taskinstance]

- [ ] **Task 6: Create indexes on task_instances table** (AC: 5)
  - [ ] Create index on workflow_instance_id for querying all tasks in a workflow
  - [ ] Create index on assigned_user_id for user task queues
  - [ ] Create index on status for filtering tasks by status
  - [ ] Create index on due_date for task prioritization
  - [ ] Create composite index on (assigned_user_id, status) for user dashboard queries
  - [ ] Create composite index on (workflow_instance_id, status) for workflow progress tracking
  - [ ] Reference: [Source: docs/architecture/database-schema.md#key-design-decisions - Strategic indexes]

- [ ] **Task 7: Create workflow_state_history table** (AC: 3, 4)
  - [ ] Add Liquibase changeset to create workflow_state_history table with structure:
    - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
    - workflow_instance_id: UUID NOT NULL (FK to workflow_instances.id)
    - previous_status: WORKFLOW_STATUS NOT NULL
    - new_status: WORKFLOW_STATUS NOT NULL
    - changed_by: UUID NOT NULL (FK to users.id)
    - changed_at: TIMESTAMP NOT NULL DEFAULT NOW()
    - notes: TEXT NULL
  - [ ] Add foreign key constraint: workflow_instance_id REFERENCES workflow_instances(id) ON DELETE CASCADE
  - [ ] Add foreign key constraint: changed_by REFERENCES users(id)
  - [ ] Reference: [Source: docs/architecture/data-models.md#workflowstatehistory]

- [ ] **Task 8: Create indexes on workflow_state_history table** (AC: 5)
  - [ ] Create index on workflow_instance_id for audit trail queries
  - [ ] Create index on changed_at for chronological audit reports
  - [ ] Create composite index on (workflow_instance_id, changed_at) for workflow history timeline
  - [ ] Reference: [Source: docs/architecture/database-schema.md#key-design-decisions - Strategic indexes]

- [ ] **Task 9: Add Liquibase changeset metadata and rollback support** (AC: 7)
  - [ ] Ensure each changeset has unique id, author, and context attributes
  - [ ] Add rollback instructions for each changeset:
    - DROP TABLE workflow_state_history
    - DROP TABLE task_instances
    - DROP TABLE workflow_instances
    - DROP TYPE TASK_STATUS
    - DROP TYPE WORKFLOW_STATUS
  - [ ] Test rollback using: `mvn liquibase:rollback -Dliquibase.rollbackCount=5`
  - [ ] Reference: [Source: docs/architecture/database-schema.md#migration-workflow]

- [ ] **Task 10: Validate Liquibase changelog structure** (AC: 7)
  - [ ] Verify changesets are added to db.changelog-master.yaml in correct order
  - [ ] Ensure changesets follow project naming convention: {epic}-{story}-{sequence}-{description}
  - [ ] Verify preconditions are set to prevent duplicate table creation
  - [ ] Run Liquibase validation: `mvn liquibase:validate`
  - [ ] Reference: [Source: docs/architecture/database-schema.md#liquibase-changelog]

- [ ] **Task 11: Write integration test for workflow_instances table** (AC: 1, 4)
  - [ ] Create test class: WorkflowInstanceRepositoryTest
  - [ ] Use @DataJpaTest and @Testcontainers for real PostgreSQL testing
  - [ ] Test: Insert workflow instance with all required fields
  - [ ] Test: Foreign key constraint validation for template_id and initiated_by
  - [ ] Test: JSONB custom_field_values can store and retrieve JSON data
  - [ ] Test: Status enum constraint rejects invalid values
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#integration-tests]

- [ ] **Task 12: Write integration test for task_instances table** (AC: 2, 4)
  - [ ] Create test class: TaskInstanceRepositoryTest
  - [ ] Use @DataJpaTest and @Testcontainers for real PostgreSQL testing
  - [ ] Test: Insert task instance with all required fields
  - [ ] Test: Foreign key constraints for workflow_instance_id, template_task_id, assigned_user_id, completed_by
  - [ ] Test: ON DELETE CASCADE when workflow_instance is deleted
  - [ ] Test: JSONB checklist_data can store and retrieve JSON data
  - [ ] Test: is_visible boolean default value is TRUE
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#integration-tests]

- [ ] **Task 13: Write integration test for workflow_state_history table** (AC: 3, 4)
  - [ ] Create test class: WorkflowStateHistoryRepositoryTest
  - [ ] Use @DataJpaTest and @Testcontainers for real PostgreSQL testing
  - [ ] Test: Insert state history record
  - [ ] Test: Foreign key constraints for workflow_instance_id and changed_by
  - [ ] Test: Query history records in chronological order by changed_at
  - [ ] Test: ON DELETE CASCADE when workflow_instance is deleted
  - [ ] Reference: [Source: docs/architecture/test-strategy.md#integration-tests]

- [ ] **Task 14: Verify database migration execution** (AC: 1, 2, 3, 4, 5, 6, 7)
  - [ ] Start PostgreSQL container: `docker-compose up -d postgres`
  - [ ] Run Spring Boot application: `mvn spring-boot:run`
  - [ ] Verify Liquibase successfully applies changesets (check console logs)
  - [ ] Connect to PostgreSQL and verify tables exist:
    - `\d workflow_instances`
    - `\d task_instances`
    - `\d workflow_state_history`
  - [ ] Verify enum types exist: `\dT` (list custom types)
  - [ ] Verify foreign key constraints: `\d+ workflow_instances` (show constraints)
  - [ ] Verify indexes: `\di` (list indexes)
  - [ ] Stop containers: `docker-compose down`
  - [ ] Reference: [Source: docs/architecture/database-schema.md#migration-workflow]

## Dev Notes

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Database Technologies for Story 3.1:**
- **Database:** PostgreSQL 17.2 (latest stable)
- **Database Migration:** Liquibase 4.25.1 (integrated with Spring Boot)
- **ORM:** Hibernate 6.4.2 via Spring Data JPA
- **Database Driver:** PostgreSQL JDBC 42.7.1
- **Connection Pool:** HikariCP 5.1.0 (default pool size 10-20)
- **Testing:** TestContainers 1.19.3 with PostgreSQL container for integration tests

### Database Design Decisions
[Source: docs/architecture/database-schema.md]

**Key Design Patterns Applied to Story 3.1:**

1. **UUID Primary Keys:** All tables use UUID primary keys generated with `gen_random_uuid()` for globally unique identifiers
2. **PostgreSQL ENUMs:** Status fields use database-level enum types (WORKFLOW_STATUS, TASK_STATUS) for type safety
3. **JSONB Columns:**
   - workflow_instances.custom_field_values: Stores flexible custom field data provided during workflow initiation
   - task_instances.checklist_data: Stores partial checklist saves for task completion
4. **Audit Columns:** created_at and updated_at on all tables with DEFAULT NOW()
5. **Foreign Key Constraints:** All relationships enforced at database level with appropriate ON DELETE actions
6. **Cascade Deletes:**
   - ON DELETE CASCADE for workflow_instances → task_instances (tasks deleted when workflow deleted)
   - ON DELETE CASCADE for workflow_instances → workflow_state_history (history deleted when workflow deleted)
7. **SET NULL on User Deletion:** assigned_user_id and completed_by use SET NULL to preserve task history when users are deleted
8. **Strategic Indexes:** Indexes on FK columns, status fields, dates, and composite indexes for common query patterns

### Data Model Relationships
[Source: docs/architecture/data-models.md]

**WorkflowInstance Entity:**
- `id`: UUID - Primary key
- `templateId`: UUID - Foreign key to WorkflowTemplate (which template was used)
- `employeeName`: String - Name of employee being onboarded/offboarded
- `employeeEmail`: String (indexed) - Employee email for notifications
- `employeeRole`: String - Employee's job role
- `workflowType`: Enum (ONBOARDING, OFFBOARDING) - Type of workflow
- `status`: Enum (INITIATED, IN_PROGRESS, BLOCKED, COMPLETED) - Current workflow state
- `initiatedBy`: UUID - Foreign key to User (who initiated this workflow)
- `initiatedAt`: Timestamp (indexed) - When workflow was started
- `completedAt`: Timestamp (nullable) - When workflow was completed
- `customFieldValues`: JSONB - Stores custom field data from template (e.g., start date, department, remote status)
- `createdAt`, `updatedAt`: Audit timestamps

**Relationships:**
- Many-to-One: WorkflowInstance → WorkflowTemplate (references template used)
- Many-to-One: WorkflowInstance → User (references initiator)
- One-to-Many: WorkflowInstance → TaskInstance (workflow contains multiple tasks)
- One-to-Many: WorkflowInstance → WorkflowStateHistory (tracks status changes)
- One-to-Many: WorkflowInstance → ProvisionedItem (tracks provisioned items for offboarding mirror)

**TaskInstance Entity:**
- `id`: UUID - Primary key
- `workflowInstanceId`: UUID (indexed) - Foreign key to WorkflowInstance
- `templateTaskId`: UUID - Foreign key to TemplateTask (which template task this was instantiated from)
- `taskName`: String - Name of the task (copied from template)
- `assignedUserId`: UUID (nullable, indexed) - Foreign key to User (who is assigned this task)
- `assignedRole`: Enum - Role responsible for this task (HR_ADMIN, LINE_MANAGER, TECH_SUPPORT, ADMINISTRATOR)
- `status`: Enum (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED) - Current task state
- `isVisible`: Boolean (default true) - For conditional logic (hidden tasks not displayed to users)
- `dueDate`: Timestamp (nullable, indexed) - Task deadline calculated from SLA
- `completedAt`: Timestamp (nullable) - When task was completed
- `completedBy`: UUID (nullable) - Foreign key to User (who completed this task)
- `checklistData`: JSONB - Stores partial checklist data for task completion forms
- `createdAt`, `updatedAt`: Audit timestamps

**Relationships:**
- Many-to-One: TaskInstance → WorkflowInstance
- Many-to-One: TaskInstance → TemplateTask (references template task definition)
- Many-to-One: TaskInstance → User (as assigned user)
- One-to-Many: TaskInstance → TaskChecklistItem (task has multiple checklist items)
- One-to-Many: TaskInstance → ProvisionedItem (tracks what was provisioned during this task)

**WorkflowStateHistory Entity:**
- `id`: UUID - Primary key
- `workflowInstanceId`: UUID (indexed) - Foreign key to WorkflowInstance
- `previousStatus`: Enum (WorkflowStatus) - Status before change
- `newStatus`: Enum (WorkflowStatus) - Status after change
- `changedBy`: UUID - Foreign key to User (who made the change)
- `changedAt`: Timestamp (indexed) - When status changed
- `notes`: String (optional) - Additional context for status change

**Relationships:**
- Many-to-One: WorkflowStateHistory → WorkflowInstance (audit trail for specific workflow)

### Liquibase Changelog Structure
[Source: docs/architecture/database-schema.md]

**Changelog Location:** `backend/src/main/resources/db/changelog/db.changelog-master.yaml`

**Changeset Naming Convention:** `{epic}-{story}-{sequence}-{description}`
- Example: `3-1-1-create-workflow-status-enum`
- Example: `3-1-2-create-task-status-enum`
- Example: `3-1-3-create-workflow-instances-table`

**Changeset Structure:**
```yaml
- changeSet:
    id: 3-1-3-create-workflow-instances-table
    author: sm-agent
    context: schema
    changes:
      - createTable:
          tableName: workflow_instances
          columns:
            - column:
                name: id
                type: UUID
                defaultValueComputed: gen_random_uuid()
                constraints:
                  primaryKey: true
                  nullable: false
            # ... more columns
    rollback:
      - dropTable:
          tableName: workflow_instances
```

**Execution:** Liquibase runs automatically on Spring Boot startup and applies new changesets incrementally.

**Rollback:** Use `mvn liquibase:rollback -Dliquibase.rollbackCount=N` to roll back N changesets.

### Source Tree Structure
[Source: docs/architecture/source-tree.md]

**File Locations for Story 3.1:**
```
backend/src/
├── main/
│   ├── java/com/magnab/employeelifecycle/
│   │   ├── entity/
│   │   │   ├── WorkflowInstance.java         # CREATE - JPA entity for workflow instances
│   │   │   ├── TaskInstance.java             # CREATE - JPA entity for task instances
│   │   │   └── WorkflowStateHistory.java     # CREATE - JPA entity for state history
│   │   ├── enums/
│   │   │   ├── WorkflowStatus.java           # CREATE - Enum for workflow status (INITIATED, IN_PROGRESS, BLOCKED, COMPLETED)
│   │   │   └── TaskStatus.java               # CREATE - Enum for task status (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED)
│   │   └── repository/
│   │       ├── WorkflowInstanceRepository.java   # CREATE - Spring Data JPA repository
│   │       ├── TaskInstanceRepository.java       # CREATE - Spring Data JPA repository
│   │       └── WorkflowStateHistoryRepository.java # CREATE - Spring Data JPA repository
│   └── resources/
│       └── db/
│           └── changelog/
│               └── db.changelog-master.yaml  # MODIFY - Add new changesets for Story 3.1
└── test/
    └── java/com/magnab/employeelifecycle/
        └── repository/
            ├── WorkflowInstanceRepositoryTest.java    # CREATE - Integration tests
            ├── TaskInstanceRepositoryTest.java        # CREATE - Integration tests
            └── WorkflowStateHistoryRepositoryTest.java # CREATE - Integration tests
```

### Previous Story Context
[Source: docs/stories/2.1.story.md, docs/stories/2.2.story.md]

**Story 2.1 (Workflow Template Data Model) Context:**
- Created workflow_templates table with id, name, description, type, is_active, audit columns
- Created template_tasks table with id, template_id, task_name, assigned_role, sequence_order, is_parallel, dependency_task_id
- Created USER_ROLE enum: HR_ADMIN, LINE_MANAGER, TECH_SUPPORT, ADMINISTRATOR
- Established Liquibase migration pattern and changeset naming convention

**Story 2.2 (Template CRUD API) Context:**
- Implemented Template CRUD endpoints: POST, GET, PUT, DELETE /api/templates
- Created DTOs for templates and tasks
- Established REST API patterns and error handling approach

**Important Notes for Story 3.1:**
- This story builds on the template schema from Story 2.1 by adding workflow instance tables
- WorkflowInstance references WorkflowTemplate (template_id FK)
- TaskInstance references both WorkflowInstance and TemplateTask (maintaining relationship to template definition)
- Status enums are separate: WORKFLOW_STATUS for workflows, TASK_STATUS for tasks (similar values but different use cases)
- USER_ROLE enum already exists from Story 2.1, so task_instances.assigned_role uses existing enum
- Liquibase changesets should follow established numbering: Continue from where Story 2.1 left off

### JSONB Usage Patterns
[Source: docs/architecture/database-schema.md]

**custom_field_values in workflow_instances:**
- Stores flexible custom field data provided by HR when initiating a workflow
- Example JSON structure:
```json
{
  "start_date": "2025-11-15",
  "department": "Engineering",
  "remote_status": "hybrid",
  "office_location": "Vancouver"
}
```

**checklist_data in task_instances:**
- Stores partial checklist saves for task completion forms
- Example JSON structure:
```json
{
  "items": [
    {"id": "item1", "description": "Laptop", "checked": true, "identifier": "LP-12345"},
    {"id": "item2", "description": "Monitor", "checked": false}
  ],
  "partial_save_at": "2025-10-31T10:30:00Z"
}
```

### Foreign Key Constraint Patterns
[Source: docs/architecture/database-schema.md]

**Cascade Delete Rules for Story 3.1:**
- workflow_instances.template_id: No cascade (preserve workflows even if template soft-deleted)
- workflow_instances.initiated_by: No cascade (preserve workflow history even if user deleted)
- task_instances.workflow_instance_id: **ON DELETE CASCADE** (tasks deleted when workflow deleted)
- task_instances.template_task_id: No cascade (preserve task instances even if template modified)
- task_instances.assigned_user_id: **SET NULL** (preserve task history, mark as unassigned if user deleted)
- task_instances.completed_by: **SET NULL** (preserve completion record even if user deleted)
- workflow_state_history.workflow_instance_id: **ON DELETE CASCADE** (history deleted when workflow deleted)
- workflow_state_history.changed_by: No cascade (preserve audit trail even if user deleted)

### Index Strategy for Performance
[Source: docs/architecture/database-schema.md]

**Query Patterns Requiring Indexes:**
1. **Dashboard queries:** Find all workflows by status and date
   - Index: (status, initiated_at) on workflow_instances
2. **User task queue:** Find all tasks assigned to specific user by status
   - Index: (assigned_user_id, status) on task_instances
3. **Workflow progress tracking:** Find all tasks in a workflow by status
   - Index: (workflow_instance_id, status) on task_instances
4. **Task prioritization:** Sort tasks by due date
   - Index: due_date on task_instances
5. **Audit trail queries:** Get workflow state history chronologically
   - Index: (workflow_instance_id, changed_at) on workflow_state_history

### Testing Strategy
[Source: docs/architecture/test-strategy.md]

**Integration Testing with TestContainers:**

Story 3.1 requires integration tests using TestContainers to validate Liquibase migrations and database constraints with a real PostgreSQL database.

**Test Configuration:**
```java
@DataJpaTest
@Testcontainers
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class WorkflowInstanceRepositoryTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:17.2-alpine")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");

    @DynamicPropertySource
    static void registerPgProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private WorkflowInstanceRepository workflowInstanceRepository;

    @Test
    void shouldCreateWorkflowInstanceWithAllFields() {
        // Test implementation
    }
}
```

**Test Coverage Requirements:**
- Test CRUD operations for all three tables
- Test foreign key constraint validation (should fail when referencing non-existent IDs)
- Test cascade delete behavior (deleting workflow should delete tasks and history)
- Test SET NULL behavior (deleting user should set assigned_user_id to NULL)
- Test JSONB storage and retrieval (insert JSON, query, verify structure)
- Test enum constraint enforcement (inserting invalid status should fail)
- Test default values (status defaults, created_at timestamps)

**Coverage Goal:** 80% coverage for repository layer (per test-strategy.md)

### Coding Standards for Story 3.1
[Source: docs/architecture/coding-standards.md]

**Critical Rules Applied to Story 3.1:**

1. **Lombok for entities only:** Use `@Entity`, `@Data`, `@NoArgsConstructor`, `@AllArgsConstructor` on entity classes
2. **Constructor injection:** Repositories are auto-injected by Spring Data JPA
3. **Return Optional for nullable queries:** Repository methods returning single results should use `Optional<T>`
4. **Specific exceptions:** Database constraint violations should throw clear exceptions (not generic RuntimeException)

**Entity Naming Conventions:**
- Entities: Singular nouns (WorkflowInstance, TaskInstance, WorkflowStateHistory)
- Repositories: EntityRepository pattern (WorkflowInstanceRepository, TaskInstanceRepository)
- Table names: Plural snake_case (workflow_instances, task_instances, workflow_state_history)
- Column names: Snake_case (employee_name, workflow_instance_id, assigned_user_id)

**Example Entity Structure:**
```java
@Entity
@Table(name = "workflow_instances")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class WorkflowInstance {

    @Id
    @GeneratedValue(generator = "UUID")
    @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator")
    @Column(name = "id", updatable = false, nullable = false)
    private UUID id;

    @Column(name = "template_id", nullable = false)
    private UUID templateId;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private WorkflowStatus status = WorkflowStatus.INITIATED;

    @Type(JsonBinaryType.class)
    @Column(name = "custom_field_values", columnDefinition = "jsonb")
    private Map<String, Object> customFieldValues;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private Timestamp createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private Timestamp updatedAt;
}
```

### MVP Scope Notes
[Source: docs/prd.md - Epic 3]

**Features Included in Story 3.1:**
- Basic workflow and task instance tables with status tracking
- JSONB support for custom_field_values (enables custom fields from templates)
- Conditional logic support via is_visible flag on task_instances
- Audit trail via workflow_state_history table

**Important Design Decision:**
- custom_field_values is JSONB (not structured tables) because custom fields are deferred to Phase 2
- For MVP, workflows use fixed employee data fields (employee_name, employee_email, employee_role)
- custom_field_values JSONB provides forward compatibility for Phase 2 custom fields feature

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**Testing Strategy:** Integration tests with TestContainers + Manual database verification

**Integration Tests (TestContainers):**
- Test WorkflowInstanceRepository CRUD operations
- Test TaskInstanceRepository CRUD operations
- Test WorkflowStateHistoryRepository CRUD operations
- Test foreign key constraint validation
- Test cascade delete behavior
- Test SET NULL behavior on user deletion
- Test JSONB storage and retrieval
- Test enum constraint enforcement
- Test default values and timestamps

**Manual Database Verification:**
- Start PostgreSQL container with Docker Compose
- Run Spring Boot application to execute Liquibase migrations
- Connect to PostgreSQL with psql or pgAdmin
- Verify table structures: `\d workflow_instances`, `\d task_instances`, `\d workflow_state_history`
- Verify enum types exist: `\dT`
- Verify foreign keys: `\d+ workflow_instances` (show constraints)
- Verify indexes: `\di`
- Test rollback: `mvn liquibase:rollback -Dliquibase.rollbackCount=5`

**Test File Locations:**
```
backend/src/test/java/com/magnab/employeelifecycle/repository/
├── WorkflowInstanceRepositoryTest.java
├── TaskInstanceRepositoryTest.java
└── WorkflowStateHistoryRepositoryTest.java
```

**Coverage Goal:** 80% coverage for repository tests (per test-strategy.md)

**No Frontend Testing:** This is a backend-only database schema story

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-31 | 1.0 | Story created from Epic 3 with complete database schema specification for workflow instances, task instances, and workflow state history. Includes Liquibase changesets, enum types, foreign key relationships, indexes, JSONB columns, cascade delete rules, and TestContainers integration tests. First story in Epic 3: Workflow Execution & Task Routing. | Bob (Scrum Master) |
| 2025-10-31 | 1.1 | Story validated and approved for implementation. Validation Score: 9.8/10 (Outstanding). Zero critical issues, zero hallucinations detected, 100% AC coverage, perfect template compliance. PO Assessment: Exemplary story preparation - ready for immediate development. | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
