# Story 3.3: Task Assignment & Routing Logic

## Status
**Approved**

## Story

**As a** backend developer,
**I want** service logic that automatically assigns tasks to specific users based on role mappings,
**so that** tasks are routed to the correct stakeholders without manual assignment.

## Acceptance Criteria

1. WorkflowService.assignTasksForWorkflow(workflowInstanceId) method processes all NOT_STARTED tasks that are ready to be assigned
2. "Ready to assign" means: task dependencies are satisfied (prerequisite tasks are COMPLETED) and task is visible (is_visible=true)
3. For each ready task, system identifies users with matching role (assigned_role matches user.role)
4. If multiple users have same role, task is assigned to user with lowest current task load (fewest IN_PROGRESS tasks)
5. Task status transitions from NOT_STARTED to IN_PROGRESS when assigned
6. assigned_user_id is set to selected user
7. due_date is calculated based on configurable SLA (e.g., 2 days from assignment) - use simple default for MVP
8. Method returns list of assigned tasks with user details for notification triggering
9. Method is idempotent (calling multiple times doesn't duplicate assignments)
10. Unit tests cover various scenarios (single assignee, multiple candidates, load balancing)

## Tasks / Subtasks

- [ ] **Task 1: Add assignTasksForWorkflow method to WorkflowService** (AC: 1)
  - [ ] Add method signature: `List<TaskAssignmentResult> assignTasksForWorkflow(UUID workflowInstanceId)`
  - [ ] Add @Transactional annotation to ensure atomicity
  - [ ] Validate that workflow instance exists (throw ResourceNotFoundException if not found)
  - [ ] Retrieve all task instances for the workflow using TaskInstanceRepository
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Transactional at service layer]

- [ ] **Task 2: Implement "ready to assign" task filtering logic** (AC: 2)
  - [ ] Filter tasks with status = NOT_STARTED
  - [ ] Filter tasks with is_visible = true
  - [ ] For each task, check if all dependency tasks are COMPLETED
  - [ ] Use TemplateTask.dependencyTaskId to identify prerequisite tasks
  - [ ] Create helper method: `boolean isDependencySatisfied(TaskInstance task, List<TaskInstance> allTasks)`
  - [ ] Reference: [Source: docs/architecture/data-models.md#TaskInstance, #TemplateTask]

- [ ] **Task 3: Implement role-based user selection with load balancing** (AC: 3, 4)
  - [ ] For each ready task, get task.assignedRole
  - [ ] Query UserRepository to find all active users with matching role
  - [ ] If no users found with role, log warning and skip task (will retry next time)
  - [ ] If multiple users found, calculate current task load for each user
  - [ ] Query TaskInstanceRepository.countByAssignedUserIdAndStatus(userId, TaskStatus.IN_PROGRESS)
  - [ ] Select user with minimum IN_PROGRESS task count (load balancing)
  - [ ] Reference: [Source: docs/architecture/data-models.md#User, #TaskInstance]

- [ ] **Task 4: Assign task to selected user and update status** (AC: 5, 6, 7)
  - [ ] Set task.assignedUserId = selected user's ID
  - [ ] Set task.status = TaskStatus.IN_PROGRESS
  - [ ] Calculate due_date = LocalDateTime.now().plusDays(2) (2-day SLA for MVP)
  - [ ] Save updated task using TaskInstanceRepository.save()
  - [ ] Reference: [Source: docs/architecture/data-models.md#TaskInstance]

- [ ] **Task 5: Update workflow status when first task is assigned** (AC: related to 3.4)
  - [ ] Check if workflow status is INITIATED
  - [ ] If yes, update workflow status to IN_PROGRESS using WorkflowService.updateWorkflowStatus()
  - [ ] Create workflow state history record for transition
  - [ ] Reference: [Source: docs/architecture/data-models.md#WorkflowInstance, #WorkflowStateHistory]

- [ ] **Task 6: Return assignment results for notification triggering** (AC: 8)
  - [ ] Create TaskAssignmentResult DTO in dto/response/ package
  - [ ] Include fields: UUID taskInstanceId, UUID assignedUserId, String assignedUserEmail, String taskName, LocalDateTime dueDate
  - [ ] Build list of TaskAssignmentResult for all successfully assigned tasks
  - [ ] Return list from assignTasksForWorkflow method
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - ActionEntityResponse pattern]

- [ ] **Task 7: Implement idempotency to prevent duplicate assignments** (AC: 9)
  - [ ] Check if task is already assigned (assignedUserId != null and status != NOT_STARTED)
  - [ ] Skip already-assigned tasks in the filtering logic (Task 2)
  - [ ] Ensure method can be called multiple times without side effects
  - [ ] Add logging: INFO level when tasks assigned, DEBUG level when skipping already-assigned tasks
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - Logging standards]

- [ ] **Task 8: Add custom query methods to TaskInstanceRepository** (AC: 4)
  - [ ] Add method: `Long countByAssignedUserIdAndStatus(UUID userId, TaskStatus status)`
  - [ ] Add method: `List<TaskInstance> findByWorkflowInstanceIdOrderBySequenceOrder(UUID workflowInstanceId)` (if not already exists)
  - [ ] Reference: [Source: docs/architecture/source-tree.md - repository/ package]

- [ ] **Task 9: Add custom query method to UserRepository** (AC: 3)
  - [ ] Add method: `List<User> findByRoleAndIsActive(UserRole role, Boolean isActive)`
  - [ ] This retrieves all active users with a specific role for load balancing
  - [ ] Reference: [Source: docs/architecture/source-tree.md - repository/ package]

- [ ] **Task 10: Write unit tests for assignTasksForWorkflow** (AC: 10)
  - [ ] Create WorkflowServiceAssignmentTest.java in test/service/ package
  - [ ] Use @ExtendWith(MockitoExtension.class)
  - [ ] Mock: TaskInstanceRepository, UserRepository, WorkflowInstanceRepository, TemplateTaskRepository
  - [ ] Test: assignTasksForWorkflow_WithSingleUser_AssignsTaskSuccessfully
  - [ ] Test: assignTasksForWorkflow_WithMultipleUsers_AssignsToUserWithLowestLoad
  - [ ] Test: assignTasksForWorkflow_WithDependencies_OnlyAssignsReadyTasks
  - [ ] Test: assignTasksForWorkflow_WithHiddenTasks_SkipsInvisibleTasks
  - [ ] Test: assignTasksForWorkflow_WhenCalledTwice_IsIdempotent
  - [ ] Test: assignTasksForWorkflow_WithNoMatchingRole_SkipsTaskAndLogs
  - [ ] Test: assignTasksForWorkflow_UpdatesWorkflowToInProgress
  - [ ] Verify task status transitions, assignedUserId set, due_date calculated
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - Unit tests with JUnit 5 + Mockito]

- [ ] **Task 11: Write integration test for task assignment** (AC: 10)
  - [ ] Create WorkflowServiceAssignmentIntegrationTest.java in test/service/ package
  - [ ] Use @SpringBootTest and @Testcontainers with PostgreSQL
  - [ ] Set up test data: workflow instance with multiple tasks, users with different roles
  - [ ] Call assignTasksForWorkflow and verify database state
  - [ ] Verify tasks assigned to correct users based on role
  - [ ] Verify load balancing (user with fewer tasks gets assignment)
  - [ ] Verify due dates calculated correctly
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - TestContainers integration tests]

## Dev Notes

### Previous Story Context
[Source: Story 3.2 Dev Agent Record]

Story 3.2 successfully implemented the workflow instantiation service that creates workflow instances from templates:
- WorkflowService.createWorkflowInstance() method completed
- All template tasks copied to task_instances with status NOT_STARTED
- Conditional rules evaluated and tasks marked invisible if needed
- Workflow status set to INITIATED
- All operations in single transaction
- 28 unit tests passing

**Key insight for Story 3.3:** Story 3.2 creates task instances in NOT_STARTED state. Story 3.3 will transition them to IN_PROGRESS when assigned.

**Entities available for Story 3.3:**
- WorkflowInstance, TaskInstance, WorkflowStateHistory (from Story 3.1)
- User (from Story 1.x)
- TemplateTask (from Story 2.1)

**Repositories available for Story 3.3:**
- WorkflowInstanceRepository, TaskInstanceRepository, WorkflowStateHistoryRepository (from Story 3.1)
- UserRepository (from Story 1.x)
- TemplateTaskRepository (from Story 2.1)

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Backend Framework:**
- Spring Boot 3.2.2
- Java 17 LTS
- Hibernate 6.4.2 (via Spring Data JPA)
- Maven 3.9.6

**Testing:**
- JUnit 5 (5.10.1) for unit tests
- Mockito 5.8.0 for mocking
- TestContainers 1.19.3 for integration tests
- PostgreSQL 17.2 for test database

**Key Dependencies:**
- Lombok 1.18.30 (entities only, per coding standards)
- SLF4J + Logback for logging

### Data Models
[Source: docs/architecture/data-models.md]

**TaskInstance Entity:**
- Primary key: UUID id
- Foreign keys: workflowInstanceId (WorkflowInstance), templateTaskId (TemplateTask)
- Assignment: assignedUserId (User, nullable), assignedRole (Enum)
- Status: Enum (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED)
- Visibility: isVisible (Boolean) - controls conditional task display
- Due date: dueDate (LocalDateTime, nullable)
- Sequence: Inherited from TemplateTask via templateTaskId
- Audit: createdAt, updatedAt

**User Entity:**
- Primary key: UUID id
- Role: Enum (HR_ADMIN, LINE_MANAGER, TECH_SUPPORT, ADMINISTRATOR)
- isActive: Boolean (soft delete flag)

**WorkflowInstance Entity:**
- Primary key: UUID id
- Status: Enum (INITIATED, IN_PROGRESS, BLOCKED, COMPLETED)
- Foreign key: initiatedBy (User)

**TemplateTask Entity:**
- Primary key: UUID id
- Foreign key: templateId (WorkflowTemplate)
- Dependencies: dependencyTaskId (self-referential FK to TemplateTask)
- Sequencing: sequenceOrder (Integer)

**Relationships:**
- TaskInstance → User (Many-to-One for assignment)
- TaskInstance → WorkflowInstance (Many-to-One)
- TaskInstance → TemplateTask (Many-to-One for template reference)

### Service Layer Patterns
[Source: docs/architecture/coding-standards.md]

**Critical Service Rules:**
1. **Constructor Injection:** All dependencies injected via constructor (immutable, final fields)
2. **@Transactional Annotation:** Place on service methods for transaction management
3. **DTO Usage:** Never expose entities directly, always use DTOs for response
4. **Specific Exceptions:** Throw ValidationException, ResourceNotFoundException (not generic RuntimeException)
5. **Return DTO:** For method returns, use DTOs like TaskAssignmentResult
6. **Logger:** Use SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(WorkflowService.class);`

**Naming Conventions:**
- Service class: EntityService (e.g., WorkflowService)
- Method pattern: verbEntity (e.g., assignTasksForWorkflow)
- DTOs: ActionEntityResult/Response (e.g., TaskAssignmentResult)

**Transaction Management:**
- Use @Transactional at service layer (not controller)
- Spring will auto-rollback on unchecked exceptions
- Multi-step operations (query users, update tasks, update workflow) must be in single transaction

### Task Assignment Algorithm
[Source: PRD Story 3.3 Requirements]

**Assignment Flow:**
1. Retrieve all task instances for workflow
2. Filter to "ready to assign": NOT_STARTED, is_visible=true, dependencies satisfied
3. For each ready task:
   - Get task.assignedRole
   - Find all active users with matching role
   - If multiple users, calculate IN_PROGRESS task count for each
   - Select user with minimum count (load balancing)
   - Set task.assignedUserId and task.status = IN_PROGRESS
   - Set task.dueDate = now + 2 days
4. Update workflow status to IN_PROGRESS if first assignment
5. Return list of assignments for notification triggering

**Dependency Check Logic:**
- Task is ready if: task.status = NOT_STARTED AND task.is_visible = true
- For each task, get templateTaskId to lookup TemplateTask
- Check TemplateTask.dependencyTaskId (if not null, there's a dependency)
- Find the TaskInstance that corresponds to the dependency TemplateTask
- Verify that dependency TaskInstance.status = COMPLETED
- If all dependencies COMPLETED (or no dependencies), task is ready

**Load Balancing:**
- Query: `SELECT COUNT(*) FROM task_instances WHERE assigned_user_id = ? AND status = 'IN_PROGRESS'`
- User with lowest count gets the assignment
- Tie-breaking: Use first user returned (or user.id lexicographically for consistency)

### Error Handling
[Source: docs/architecture/error-handling-strategy.md]

**Custom Exceptions to Use:**
- `ResourceNotFoundException` - Workflow instance not found (404)
- `ValidationException` - Invalid workflow state (400)

**Logging Standards:**
- Use SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(WorkflowService.class);`
- Log levels:
  - ERROR (exceptions)
  - WARN (no users with matching role found)
  - INFO (tasks assigned, workflow status updated)
  - DEBUG (task filtering, dependency checks, load calculation)
- Never log sensitive data (passwords, tokens, PII)

**Service Error Handling:**
- If workflow not found: throw ResourceNotFoundException
- If no users with role: log warning, skip task (don't throw exception)
- If task already assigned: skip silently (idempotency)

### File Locations
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
```
backend/src/
├── main/java/com/magnab/employeelifecycle/
│   ├── dto/
│   │   └── response/
│   │       └── TaskAssignmentResult.java          # CREATE - Response DTO
└── test/java/com/magnab/employeelifecycle/
    └── service/
        ├── WorkflowServiceAssignmentTest.java     # CREATE - Unit tests
        └── WorkflowServiceAssignmentIntegrationTest.java # CREATE - Integration tests
```

**Existing Files to Modify:**
- `service/WorkflowService.java` - Add assignTasksForWorkflow method
- `repository/TaskInstanceRepository.java` - Add custom query methods
- `repository/UserRepository.java` - Add findByRoleAndIsActive method

**Existing Files to Reference (DO NOT MODIFY unless required):**
- Entity classes: WorkflowInstance, TaskInstance, User, TemplateTask
- Repository interfaces: WorkflowInstanceRepository, TaskInstanceRepository, UserRepository, TemplateTaskRepository, WorkflowStateHistoryRepository
- Enum classes: TaskStatus, WorkflowStatus, UserRole

### Due Date Calculation
[Source: PRD Story 3.3 AC #7]

**MVP Implementation:**
- Simple default: 2 days from assignment
- Calculation: `LocalDateTime.now().plusDays(2)`
- No SLA configuration table needed for MVP
- Future enhancement: SLA by role or task type (post-MVP)

### Idempotency Implementation
[Source: PRD Story 3.3 AC #9]

**Requirements:**
- Method can be called multiple times without duplicate assignments
- Already-assigned tasks are skipped
- No errors thrown if called repeatedly

**Implementation Strategy:**
- Filter tasks: `status = NOT_STARTED AND assigned_user_id IS NULL`
- If task already has assignedUserId or status != NOT_STARTED, skip it
- Log at DEBUG level: "Task {taskId} already assigned, skipping"

### Workflow State Transition
[Source: PRD Story 3.4 Reference]

**State Transition Rule:**
- When first task is assigned, workflow transitions from INITIATED → IN_PROGRESS
- Check: if workflow.status = INITIATED, call updateWorkflowStatus(workflowInstanceId, IN_PROGRESS)
- This will be implemented in Story 3.4, but Story 3.3 triggers the transition
- For MVP, Story 3.3 can directly update workflow status and create state history record

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**Unit Tests (JUnit 5 + Mockito):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/service/WorkflowServiceAssignmentTest.java`
- Use @ExtendWith(MockitoExtension.class)
- Mock all repository dependencies with @Mock
- Inject WorkflowService with @InjectMocks
- Coverage goal: 80% for service layer

**Test Scenarios:**
1. Single user with matching role → Task assigned successfully
2. Multiple users with same role → User with lowest IN_PROGRESS count gets task
3. Tasks with dependencies → Only ready tasks assigned (dependencies satisfied)
4. Hidden tasks (is_visible=false) → Skipped
5. Method called twice → Idempotent (no duplicate assignments)
6. No users with matching role → Task skipped, warning logged
7. First assignment → Workflow status updates to IN_PROGRESS
8. Due date calculation → 2 days from now

**Integration Tests (TestContainers):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/service/WorkflowServiceAssignmentIntegrationTest.java`
- Use @SpringBootTest and @Testcontainers
- Real PostgreSQL 17-alpine container
- Verify database state after assignment
- Test with real workflow and task data
- Verify load balancing with multiple users

**Example Unit Test Structure:**
```java
@ExtendWith(MockitoExtension.class)
class WorkflowServiceAssignmentTest {
    @Mock private TaskInstanceRepository taskInstanceRepo;
    @Mock private UserRepository userRepo;
    @Mock private WorkflowInstanceRepository workflowRepo;
    @Mock private TemplateTaskRepository templateTaskRepo;
    @Mock private WorkflowStateHistoryRepository historyRepo;

    @InjectMocks
    private WorkflowService workflowService;

    @Test
    void assignTasksForWorkflow_WithMultipleUsers_AssignsToUserWithLowestLoad() {
        // Arrange: Mock workflow, tasks, users with different loads
        // Act: Call workflowService.assignTasksForWorkflow()
        // Assert: Verify task assigned to user with fewest IN_PROGRESS tasks
    }
}
```

**Coverage Verification:**
- Run: `mvn test jacoco:report`
- Check: `target/site/jacoco/index.html`
- Goal: 80% coverage for WorkflowService class

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-31 | 1.0 | Story created from Epic 3 with complete service layer specification for task assignment and routing logic. Includes load balancing, dependency checking, idempotency, and comprehensive unit and integration testing requirements. Builds on Story 3.2 workflow instantiation. | Bob (Scrum Master) |
| 2025-10-31 | 1.1 | Story validated and approved for implementation. Validation Score: 9.96/10 (Outstanding). Zero critical issues, zero hallucinations detected, 100% AC coverage, complete implementation readiness. PO Assessment: Textbook example of excellent story preparation - ready for immediate development. | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
