# Story 3.6: Workflow List & Detail API

## Status
**Approved**

## Story

**As a** user (any role),
**I want** API endpoints to retrieve workflows relevant to my role,
**so that** I can see workflows I'm involved in and their current status.

## Acceptance Criteria

1. API endpoint GET /api/workflows returns paginated list of workflows (50 per page)
2. HR_ADMIN sees all workflows; other roles see only workflows where they have assigned tasks
3. Response includes summary per workflow: id, employee_name, workflow_type, status, initiated_at, total_tasks, completed_tasks
4. Query parameters support filtering by: status, workflow_type, employee_name (search)
5. Query parameters support sorting by: initiated_at, employee_name, status
6. API endpoint GET /api/workflows/{id} returns complete workflow details
7. Detail response includes: workflow metadata, custom field values, all task instances (even hidden ones for admin), state history
8. Non-admin users can only view workflows they're involved in (403 if not)
9. Both endpoints return 404 if workflow not found
10. Swagger documentation includes example request/response

## Tasks / Subtasks

- [ ] **Task 1: Create WorkflowSummaryResponse DTO** (AC: 3)
  - [ ] Create WorkflowSummaryResponse.java in dto/response/ package
  - [ ] Add fields: UUID id, String employeeName, WorkflowType workflowType, WorkflowStatus status, LocalDateTime initiatedAt, Integer totalTasks, Integer completedTasks
  - [ ] Use Lombok @Data annotation for getters/setters
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - ActionEntityResponse pattern]

- [ ] **Task 2: Create WorkflowDetailResponse DTO** (AC: 6, 7)
  - [ ] Create WorkflowDetailResponse.java in dto/response/ package
  - [ ] Add workflow metadata fields: UUID id, String employeeName, String employeeEmail, String employeeRole, WorkflowType workflowType, WorkflowStatus status, LocalDateTime initiatedAt, LocalDateTime completedAt, UUID initiatedBy
  - [ ] Add Map<String, Object> customFieldValues for custom field data
  - [ ] Add List<TaskInstanceSummary> tasks for all task instances
  - [ ] Add List<WorkflowStateHistoryEntry> stateHistory for audit trail
  - [ ] Use Lombok @Data annotation
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Response DTOs]

- [ ] **Task 3: Create TaskInstanceSummary nested DTO** (AC: 7)
  - [ ] Create TaskInstanceSummary.java as inner class or separate DTO in dto/response/ package
  - [ ] Add fields: UUID id, String taskName, TaskStatus status, UUID assignedUserId, String assignedUserName, String assignedRole, Boolean isVisible, LocalDateTime dueDate, LocalDateTime completedAt, UUID completedBy
  - [ ] Use Lombok @Data annotation
  - [ ] Reference: [Source: docs/architecture/data-models.md#TaskInstance]

- [ ] **Task 4: Create WorkflowStateHistoryEntry nested DTO** (AC: 7)
  - [ ] Create WorkflowStateHistoryEntry.java as inner class or separate DTO in dto/response/ package
  - [ ] Add fields: UUID id, WorkflowStatus previousStatus, WorkflowStatus newStatus, UUID changedBy, String changedByName, LocalDateTime changedAt, String notes
  - [ ] Use Lombok @Data annotation
  - [ ] Reference: [Source: docs/architecture/data-models.md#WorkflowStateHistory]

- [ ] **Task 5: Add getWorkflows method to WorkflowService** (AC: 1, 2, 3, 4, 5)
  - [ ] Add method signature: `Page<WorkflowSummaryResponse> getWorkflows(String status, String workflowType, String employeeNameSearch, String sortBy, String sortDirection, int page, int size, UUID currentUserId, UserRole currentUserRole)`
  - [ ] Add @Transactional(readOnly = true) annotation for read-only transaction
  - [ ] Build dynamic query based on filters: status, workflowType, employeeNameSearch
  - [ ] If currentUserRole is HR_ADMIN, return all workflows
  - [ ] If currentUserRole is not HR_ADMIN, filter to workflows where user has assigned tasks (join with task_instances)
  - [ ] Apply sorting based on sortBy parameter (default: initiatedAt descending)
  - [ ] Use Spring Data PageRequest for pagination (page, size)
  - [ ] For each workflow, calculate totalTasks and completedTasks by querying task_instances
  - [ ] Map WorkflowInstance entities to WorkflowSummaryResponse DTOs
  - [ ] Return Page<WorkflowSummaryResponse>
  - [ ] Reference: [Source: docs/architecture/rest-api-spec.md - Pagination on all list endpoints]

- [ ] **Task 6: Add getWorkflowById method to WorkflowService** (AC: 6, 7, 8)
  - [ ] Add method signature: `WorkflowDetailResponse getWorkflowById(UUID workflowId, UUID currentUserId, UserRole currentUserRole)`
  - [ ] Add @Transactional(readOnly = true) annotation
  - [ ] Retrieve workflow instance by ID using WorkflowInstanceRepository
  - [ ] If workflow not found, throw ResourceNotFoundException
  - [ ] If currentUserRole is not HR_ADMIN, verify user has assigned tasks in this workflow
  - [ ] If user not involved and not HR_ADMIN, throw ForbiddenException (403)
  - [ ] Retrieve all task instances for workflow using TaskInstanceRepository
  - [ ] For non-HR_ADMIN users, can see all tasks but with visibility flag
  - [ ] Retrieve workflow state history using WorkflowStateHistoryRepository
  - [ ] Map entities to WorkflowDetailResponse DTO with nested TaskInstanceSummary and WorkflowStateHistoryEntry
  - [ ] Return WorkflowDetailResponse
  - [ ] Reference: [Source: docs/architecture/security.md - Role-based data access]

- [ ] **Task 7: Add custom repository query methods** (AC: 2, 5)
  - [ ] In WorkflowInstanceRepository, add: `Page<WorkflowInstance> findAllByFilters(String status, String workflowType, String employeeNameSearch, Pageable pageable)`
  - [ ] In WorkflowInstanceRepository, add: `Page<WorkflowInstance> findByUserHasAssignedTasks(UUID userId, String status, String workflowType, String employeeNameSearch, Pageable pageable)`
  - [ ] Use @Query with JPQL for custom filtering and joining with task_instances
  - [ ] Support case-insensitive search for employee_name using LOWER() function
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - All database queries via repositories]

- [ ] **Task 8: Add GET /api/workflows endpoint to WorkflowController** (AC: 1, 2, 3, 4, 5)
  - [ ] Add method: `ResponseEntity<Page<WorkflowSummaryResponse>> getWorkflows(@RequestParam(required = false) String status, @RequestParam(required = false) String workflowType, @RequestParam(required = false) String employeeName, @RequestParam(defaultValue = "initiatedAt") String sortBy, @RequestParam(defaultValue = "desc") String sortDirection, @RequestParam(defaultValue = "0") int page, @RequestParam(defaultValue = "50") int size)`
  - [ ] Add @GetMapping annotation (no additional path)
  - [ ] Add @PreAuthorize("isAuthenticated()") - all authenticated users can access
  - [ ] Get current user ID and role from SecurityContext
  - [ ] Call WorkflowService.getWorkflows() with all parameters
  - [ ] Return ResponseEntity.ok(result)
  - [ ] Log request: log.info("Fetching workflows for user: {}, role: {}, filters: status={}, type={}, name={}", userId, role, status, workflowType, employeeName)
  - [ ] Reference: [Source: docs/architecture/rest-api-spec.md - Pagination default 50 items]

- [ ] **Task 9: Add GET /api/workflows/{id} endpoint to WorkflowController** (AC: 6, 7, 8, 9)
  - [ ] Add method: `ResponseEntity<WorkflowDetailResponse> getWorkflowById(@PathVariable UUID id)`
  - [ ] Add @GetMapping("/{id}") annotation
  - [ ] Add @PreAuthorize("isAuthenticated()") - all authenticated users can access
  - [ ] Get current user ID and role from SecurityContext
  - [ ] Call WorkflowService.getWorkflowById(id, userId, role)
  - [ ] Return ResponseEntity.ok(result)
  - [ ] If ResourceNotFoundException thrown, GlobalExceptionHandler returns 404
  - [ ] If ForbiddenException thrown, GlobalExceptionHandler returns 403
  - [ ] Log request: log.info("Fetching workflow details: {} for user: {}", id, userId)
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - Exception handling flow]

- [ ] **Task 10: Add OpenAPI/Swagger documentation** (AC: 10)
  - [ ] Add @Operation annotation to getWorkflows with summary: "Get paginated list of workflows"
  - [ ] Add @ApiResponses with 200 OK, 400 Bad Request responses
  - [ ] Add @Parameter annotations for query parameters with descriptions
  - [ ] Example: @Parameter(name = "status", description = "Filter by workflow status (INITIATED, IN_PROGRESS, BLOCKED, COMPLETED)")
  - [ ] Add @Operation annotation to getWorkflowById with summary: "Get detailed workflow information"
  - [ ] Add @ApiResponses with 200 OK, 403 Forbidden, 404 Not Found responses
  - [ ] Add example responses for both endpoints
  - [ ] Reference: [Source: docs/architecture/tech-stack.md - SpringDoc OpenAPI 2.3.0]

- [ ] **Task 11: Write unit tests for WorkflowController GET endpoints** (AC: 1-10)
  - [ ] Extend WorkflowControllerTest.java in test/controller/ package
  - [ ] Test: getWorkflows_AsHRAdmin_ReturnsAllWorkflows
  - [ ] Test: getWorkflows_AsNonHRAdmin_ReturnsOnlyUserWorkflows
  - [ ] Test: getWorkflows_WithFilters_AppliesFiltersCorrectly
  - [ ] Test: getWorkflows_WithSorting_ReturnsSortedResults
  - [ ] Test: getWorkflows_WithPagination_ReturnsCorrectPage
  - [ ] Test: getWorkflowById_AsHRAdmin_ReturnsWorkflowDetails
  - [ ] Test: getWorkflowById_AsNonHRAdminWithAccess_ReturnsWorkflowDetails
  - [ ] Test: getWorkflowById_AsNonHRAdminWithoutAccess_Returns403Forbidden
  - [ ] Test: getWorkflowById_WorkflowNotFound_Returns404NotFound
  - [ ] Verify service methods called with correct parameters
  - [ ] Verify response DTOs populated correctly
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - Unit tests with JUnit 5 + Mockito]

- [ ] **Task 12: Write unit tests for WorkflowService retrieval methods** (AC: 1-9)
  - [ ] Create WorkflowServiceRetrievalTest.java in test/service/ package
  - [ ] Use @ExtendWith(MockitoExtension.class)
  - [ ] Mock: WorkflowInstanceRepository, TaskInstanceRepository, WorkflowStateHistoryRepository, UserRepository
  - [ ] Test: getWorkflows_AsHRAdmin_ReturnsAllWorkflows
  - [ ] Test: getWorkflows_AsNonHRAdmin_FiltersToUserWorkflows
  - [ ] Test: getWorkflows_WithFilters_BuildsCorrectQuery
  - [ ] Test: getWorkflows_CalculatesTaskCountsCorrectly
  - [ ] Test: getWorkflowById_WorkflowExists_ReturnsDetails
  - [ ] Test: getWorkflowById_WorkflowNotFound_ThrowsResourceNotFoundException
  - [ ] Test: getWorkflowById_UserNotInvolvedAndNotAdmin_ThrowsForbiddenException
  - [ ] Test: getWorkflowById_IncludesAllTasksAndHistory
  - [ ] Verify DTOs populated with correct data from entities
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - 80% service layer coverage]

- [ ] **Task 13: Write integration test for workflow retrieval endpoints** (AC: 1-10)
  - [ ] Extend WorkflowControllerIntegrationTest.java in test/controller/ package
  - [ ] Set up test data: Multiple workflows with different statuses, users with different roles, task assignments
  - [ ] Test: GET /api/workflows as HR_ADMIN returns all workflows
  - [ ] Test: GET /api/workflows as LINE_MANAGER returns only workflows with user's tasks
  - [ ] Test: GET /api/workflows with status filter returns filtered results
  - [ ] Test: GET /api/workflows with pagination returns correct page
  - [ ] Test: GET /api/workflows/{id} as HR_ADMIN returns full details
  - [ ] Test: GET /api/workflows/{id} as non-admin with access returns details
  - [ ] Test: GET /api/workflows/{id} as non-admin without access returns 403
  - [ ] Test: GET /api/workflows/{id} with invalid ID returns 404
  - [ ] Verify database queries executed correctly
  - [ ] Verify JSON response structure matches DTOs
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - TestContainers integration tests]

## Dev Notes

### Previous Story Context

**Story 3.5: Workflow Initiation API (Approved)**

Story 3.5 created the WorkflowController with POST /api/workflows endpoint:
- WorkflowController.java exists in controller/ package
- Uses constructor injection for WorkflowService
- Implements @PreAuthorize for role-based access control
- Returns ResponseEntity with appropriate HTTP status codes
- Story 3.6 will extend this controller with GET endpoints

**Integration Pattern:**
Story 3.6 adds read operations to complement the write operation from Story 3.5:
1. GET /api/workflows - list view with pagination, filtering, sorting
2. GET /api/workflows/{id} - detail view with complete workflow information
3. Implements role-based data visibility (HR_ADMIN sees all, others see only their workflows)

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Backend Framework:**
- Spring Boot 3.2.2
- Java 17 LTS
- Spring Data JPA with Hibernate 6.4.2
- Maven 3.9.6

**Security:**
- Spring Security 6.2.1
- Session-based authentication
- @PreAuthorize for method-level security

**Pagination:**
- Spring Data Page<T> and Pageable
- Default page size: 50 items per page

**Testing:**
- JUnit 5 (5.10.1) for unit tests
- Mockito 5.8.0 for mocking
- TestContainers 1.19.3 for integration tests

### REST API Patterns
[Source: docs/architecture/rest-api-spec.md]

**Base URL:** http://localhost:8080/api

**Pagination:**
- All list endpoints support pagination (default 50 per page)
- Query parameters: page (0-indexed), size (items per page)
- Response: Spring Data Page<T> with content, totalElements, totalPages, number, size

**Filtering:**
- Query parameters for filtering: status, workflow_type, employee_name
- Case-insensitive search for text fields
- Optional parameters (null = no filter applied)

**Sorting:**
- Query parameters: sortBy (field name), sortDirection (asc/desc)
- Default sort: initiated_at descending (newest first)
- Supported sort fields: initiated_at, employee_name, status

**Key Design Decisions:**
1. Role-based data visibility enforced at service layer
2. Pagination prevents performance issues with large datasets
3. Filtering and sorting for user convenience
4. DTOs separate list view (summary) from detail view
5. All authenticated users can access GET endpoints (with role-based filtering)

### Security & Authorization
[Source: docs/architecture/security.md]

**Data Visibility Rules:**
- **HR_ADMIN:** Can see all workflows in the system
- **Other roles (LINE_MANAGER, TECH_SUPPORT, ADMINISTRATOR):** Can only see workflows where they have assigned tasks

**Authorization Pattern:**
```java
@PreAuthorize("isAuthenticated()")
@GetMapping
public ResponseEntity<Page<WorkflowSummaryResponse>> getWorkflows(...) {
    // All authenticated users can access, but service layer filters by role
}
```

**Service Layer Filtering:**
```java
public Page<WorkflowSummaryResponse> getWorkflows(..., UUID currentUserId, UserRole currentUserRole) {
    if (currentUserRole == UserRole.HR_ADMIN) {
        // Return all workflows
    } else {
        // Return only workflows where user has assigned tasks
    }
}
```

**Access Control for Detail View:**
- HR_ADMIN: Can view any workflow details
- Other roles: Can only view workflows they're involved in (403 Forbidden otherwise)

### Controller Layer Patterns
[Source: docs/architecture/coding-standards.md]

**Critical Controller Rules:**
1. **@RequestParam for query parameters:** Use optional parameters with default values
2. **@PathVariable for URL path variables:** Use for resource IDs
3. **@PreAuthorize("isAuthenticated()"):** All authenticated users can access (role filtering in service)
4. **Return ResponseEntity<T>:** Use for explicit HTTP status codes
5. **No business logic in controller:** Delegate to service layer

**Query Parameter Pattern:**
```java
@GetMapping
public ResponseEntity<Page<WorkflowSummaryResponse>> getWorkflows(
        @RequestParam(required = false) String status,
        @RequestParam(required = false) String workflowType,
        @RequestParam(required = false) String employeeName,
        @RequestParam(defaultValue = "initiatedAt") String sortBy,
        @RequestParam(defaultValue = "desc") String sortDirection,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "50") int size) {
    // Implementation
}
```

**Path Variable Pattern:**
```java
@GetMapping("/{id}")
public ResponseEntity<WorkflowDetailResponse> getWorkflowById(@PathVariable UUID id) {
    // Implementation
}
```

### Pagination Implementation
[Source: docs/architecture/rest-api-spec.md]

**Spring Data Pagination:**
```java
// Controller
int page = 0; // 0-indexed
int size = 50; // items per page

// Service
Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "initiatedAt"));
Page<WorkflowInstance> workflowPage = workflowInstanceRepository.findAll(pageable);

// Map to DTOs
Page<WorkflowSummaryResponse> responsePage = workflowPage.map(this::mapToSummaryDTO);
return responsePage;
```

**Page Response Structure:**
```json
{
  "content": [ /* array of WorkflowSummaryResponse */ ],
  "pageable": { "sort": {...}, "offset": 0, "pageNumber": 0, "pageSize": 50 },
  "totalElements": 150,
  "totalPages": 3,
  "last": false,
  "first": true,
  "size": 50,
  "number": 0,
  "numberOfElements": 50
}
```

### DTO Design
[Source: docs/architecture/coding-standards.md]

**WorkflowSummaryResponse (List View):**
```java
@Data
public class WorkflowSummaryResponse {
    private UUID id;
    private String employeeName;
    private WorkflowType workflowType;
    private WorkflowStatus status;
    private LocalDateTime initiatedAt;
    private Integer totalTasks;
    private Integer completedTasks;
}
```

**WorkflowDetailResponse (Detail View):**
```java
@Data
public class WorkflowDetailResponse {
    private UUID id;
    private String employeeName;
    private String employeeEmail;
    private String employeeRole;
    private WorkflowType workflowType;
    private WorkflowStatus status;
    private LocalDateTime initiatedAt;
    private LocalDateTime completedAt;
    private UUID initiatedBy;
    private Map<String, Object> customFieldValues;
    private List<TaskInstanceSummary> tasks;
    private List<WorkflowStateHistoryEntry> stateHistory;
}

@Data
public class TaskInstanceSummary {
    private UUID id;
    private String taskName;
    private TaskStatus status;
    private UUID assignedUserId;
    private String assignedUserName;
    private String assignedRole;
    private Boolean isVisible;
    private LocalDateTime dueDate;
    private LocalDateTime completedAt;
    private UUID completedBy;
}

@Data
public class WorkflowStateHistoryEntry {
    private UUID id;
    private WorkflowStatus previousStatus;
    private WorkflowStatus newStatus;
    private UUID changedBy;
    private String changedByName;
    private LocalDateTime changedAt;
    private String notes;
}
```

**Key Points:**
- Summary DTO for list view (lightweight, essential fields only)
- Detail DTO for single view (comprehensive, includes nested collections)
- Use Lombok @Data for brevity
- Nested DTOs for related entities (tasks, state history)

### Data Models Referenced
[Source: docs/architecture/data-models.md]

**WorkflowInstance Entity:**
- Primary key: UUID id
- Employee details: String employeeName, String employeeEmail, String employeeRole
- Workflow metadata: UUID templateId, WorkflowType workflowType, WorkflowStatus status
- Timestamps: LocalDateTime initiatedAt, LocalDateTime completedAt (nullable)
- Custom data: Map<String, Object> customFieldValues (JSONB)
- Audit: UUID initiatedBy, LocalDateTime createdAt, LocalDateTime updatedAt

**TaskInstance Entity:**
- Primary key: UUID id
- Foreign keys: UUID workflowInstanceId, UUID templateTaskId
- Assignment: UUID assignedUserId (nullable), String assignedRole
- Status: TaskStatus status (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED)
- Visibility: Boolean isVisible (for conditional tasks)
- Timestamps: LocalDateTime dueDate, LocalDateTime completedAt, UUID completedBy

**WorkflowStateHistory Entity:**
- Primary key: UUID id
- Foreign key: UUID workflowInstanceId
- State tracking: WorkflowStatus previousStatus, WorkflowStatus newStatus
- Audit: UUID changedBy, LocalDateTime changedAt, String notes

**Enums:**
- WorkflowStatus: INITIATED, IN_PROGRESS, BLOCKED, COMPLETED
- TaskStatus: NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED
- WorkflowType: ONBOARDING, OFFBOARDING
- UserRole: HR_ADMIN, LINE_MANAGER, TECH_SUPPORT, ADMINISTRATOR

### Service Layer Implementation
[Source: docs/architecture/coding-standards.md]

**Repository Query Strategy:**
- Use Spring Data JPA custom queries with @Query annotation
- Support dynamic filtering with optional parameters
- Join with task_instances table for role-based filtering
- Use LOWER() for case-insensitive search
- Return Page<T> for pagination support

**Example Custom Repository Query:**
```java
@Query("SELECT DISTINCT w FROM WorkflowInstance w " +
       "JOIN TaskInstance t ON t.workflowInstanceId = w.id " +
       "WHERE t.assignedUserId = :userId " +
       "AND (:status IS NULL OR w.status = :status) " +
       "AND (:workflowType IS NULL OR w.workflowType = :workflowType) " +
       "AND (:employeeNameSearch IS NULL OR LOWER(w.employeeName) LIKE LOWER(CONCAT('%', :employeeNameSearch, '%')))")
Page<WorkflowInstance> findByUserHasAssignedTasks(
    @Param("userId") UUID userId,
    @Param("status") String status,
    @Param("workflowType") String workflowType,
    @Param("employeeNameSearch") String employeeNameSearch,
    Pageable pageable);
```

**Task Count Calculation:**
- Query task_instances for each workflow to get totalTasks and completedTasks
- Could be optimized with JOIN and GROUP BY, but simpler approach: query per workflow in list
- For detail view, retrieve all tasks and include in response

### Error Handling
[Source: docs/architecture/error-handling-strategy.md]

**Custom Exceptions:**
- `ResourceNotFoundException` - Workflow not found (404)
- `ForbiddenException` - User not authorized to view workflow (403)

**Error Messages:**
- "Workflow with ID {id} not found"
- "Access denied: You are not authorized to view this workflow"

**Exception Flow:**
1. Controller calls service method
2. Service throws specific exception
3. GlobalExceptionHandler catches exception
4. GlobalExceptionHandler returns appropriate HTTP status with error details

### File Locations
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
```
backend/src/
├── main/java/com/magnab/employeelifecycle/
│   ├── dto/
│   │   └── response/
│   │       ├── WorkflowSummaryResponse.java          # CREATE - List view DTO
│   │       ├── WorkflowDetailResponse.java           # CREATE - Detail view DTO
│   │       ├── TaskInstanceSummary.java              # CREATE - Nested DTO
│   │       └── WorkflowStateHistoryEntry.java        # CREATE - Nested DTO
└── test/java/com/magnab/employeelifecycle/
    ├── controller/
    │   └── WorkflowControllerTest.java                # EXTEND - Add GET tests
    └── service/
        └── WorkflowServiceRetrievalTest.java          # CREATE - Service tests
```

**Existing Files to Modify:**
- `controller/WorkflowController.java` - Add GET /api/workflows and GET /api/workflows/{id} endpoints
- `service/WorkflowService.java` - Add getWorkflows() and getWorkflowById() methods
- `repository/WorkflowInstanceRepository.java` - Add custom query methods
- `test/controller/WorkflowControllerIntegrationTest.java` - Add integration tests for GET endpoints

**Existing Files to Reference (DO NOT MODIFY):**
- `entity/WorkflowInstance.java`, `entity/TaskInstance.java`, `entity/WorkflowStateHistory.java`
- `enums/WorkflowStatus.java`, `enums/TaskStatus.java`, `enums/WorkflowType.java`, `enums/UserRole.java`
- `exception/ResourceNotFoundException.java`, `exception/ForbiddenException.java`
- `exception/GlobalExceptionHandler.java`

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**Unit Tests (JUnit 5 + Mockito):**
- Controller tests: WorkflowControllerTest.java (extend existing)
- Service tests: WorkflowServiceRetrievalTest.java (new)
- Mock all repository dependencies
- Coverage goal: 80% for controller and service layers

**Test Scenarios:**
1. List workflows as HR_ADMIN → Returns all workflows
2. List workflows as non-HR_ADMIN → Returns only user's workflows
3. List workflows with filters → Applies correct filters
4. List workflows with sorting → Returns sorted results
5. List workflows with pagination → Returns correct page
6. Get workflow detail as HR_ADMIN → Returns full details
7. Get workflow detail as non-HR_ADMIN with access → Returns details
8. Get workflow detail as non-HR_ADMIN without access → 403 Forbidden
9. Get workflow detail for non-existent workflow → 404 Not Found
10. Repository queries executed correctly

**Integration Tests (TestContainers):**
- Test file: WorkflowControllerIntegrationTest.java (extend existing)
- Use @SpringBootTest and @Testcontainers
- Real PostgreSQL 17-alpine container
- Test full request-to-database flow
- Verify role-based data filtering
- Verify pagination, filtering, sorting work correctly
- Verify JSON response structure

**Example Unit Test Structure:**
```java
@ExtendWith(MockitoExtension.class)
class WorkflowServiceRetrievalTest {
    @Mock private WorkflowInstanceRepository workflowRepo;
    @Mock private TaskInstanceRepository taskRepo;
    @Mock private WorkflowStateHistoryRepository historyRepo;
    @InjectMocks private WorkflowService workflowService;

    @Test
    void getWorkflows_AsHRAdmin_ReturnsAllWorkflows() {
        // Arrange: Mock repository to return all workflows
        Page<WorkflowInstance> mockPage = new PageImpl<>(List.of(workflow1, workflow2));
        when(workflowRepo.findAllByFilters(any(), any(), any(), any()))
            .thenReturn(mockPage);

        // Act: Call getWorkflows with HR_ADMIN role
        Page<WorkflowSummaryResponse> result = workflowService.getWorkflows(
            null, null, null, "initiatedAt", "desc", 0, 50, adminUserId, UserRole.HR_ADMIN
        );

        // Assert: Verify all workflows returned
        assertEquals(2, result.getContent().size());
        verify(workflowRepo).findAllByFilters(any(), any(), any(), any());
    }

    @Test
    void getWorkflowById_UserNotInvolvedAndNotAdmin_ThrowsForbiddenException() {
        // Arrange: Mock workflow exists but user has no tasks
        when(workflowRepo.findById(workflowId)).thenReturn(Optional.of(workflow));
        when(taskRepo.existsByWorkflowInstanceIdAndAssignedUserId(workflowId, userId))
            .thenReturn(false);

        // Act & Assert: Verify ForbiddenException thrown
        assertThrows(ForbiddenException.class, () ->
            workflowService.getWorkflowById(workflowId, userId, UserRole.LINE_MANAGER)
        );
    }
}
```

**Coverage Verification:**
- Run: `mvn test jacoco:report`
- Check: `target/site/jacoco/index.html`
- Goal: 80% coverage for WorkflowController and WorkflowService

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-31 | 1.1 | Story validated and approved. Comprehensive validation completed: template compliance verified, all 10 ACs covered, role-based security implementation comprehensive, pagination/filtering/sorting patterns verified, anti-hallucination verification passed, implementation readiness confirmed (10/10 score). Status updated from Draft to Approved. | Sarah (Product Owner) |
| 2025-10-31 | 1.0 | Story created from Epic 3 with complete workflow retrieval API specification. Includes GET endpoints for list and detail views, pagination, filtering, sorting, role-based data visibility, comprehensive DTOs for summary and detail responses, and full unit and integration testing requirements. Extends WorkflowController from Story 3.5. | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
