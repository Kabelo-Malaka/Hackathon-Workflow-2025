# Story 2.2: Template CRUD API Endpoints

## Status
**Approved**

## Story

**As a** backend developer,
**I want** REST API endpoints for template CRUD operations,
**so that** the frontend can create, retrieve, update, and delete workflow templates.

## Acceptance Criteria

1. API endpoints exist: POST /api/templates, GET /api/templates, GET /api/templates/{id}, PUT /api/templates/{id}, DELETE /api/templates/{id}
2. Only HR_ADMIN and ADMINISTRATOR roles can access template management endpoints
3. POST creates new template with tasks in single transaction *(MVP: no custom fields or conditional rules)*
4. GET /api/templates returns list of all templates with summary info (id, name, type, is_active)
5. GET /api/templates/{id} returns complete template details including all tasks *(MVP: no custom fields or conditional rules)*
6. PUT updates template and cascades updates to tasks (replaces entire structure)
7. DELETE soft-deletes template (sets is_active=false) to preserve history
8. Templates cannot be deleted if they're in use by active workflows (return 409 Conflict with message)
9. API uses DTOs for request/response (TemplateDTO, TaskDTO) *(MVP: no CustomFieldDTO or ConditionalRuleDTO)*
10. All operations update audit columns and are logged for audit trail
11. Swagger documentation is auto-generated for all endpoints

## Tasks / Subtasks

- [ ] **Task 1: Create DTO classes for template API** (AC: 9)
  - [ ] Create `backend/src/main/java/com/magnab/employeelifecycle/dto/request/CreateTemplateRequest.java`
  - [ ] Add fields: name (String, required), description (String, optional), type (WorkflowType enum, required), tasks (List<CreateTemplateTaskRequest>, required)
  - [ ] Add Jakarta Bean Validation annotations: @NotNull, @NotBlank, @Valid, @Size
  - [ ] Create `backend/src/main/java/com/magnab/employeelifecycle/dto/request/CreateTemplateTaskRequest.java`
  - [ ] Add fields: taskName (String, required), description (String, optional), assignedRole (UserRole enum, required), sequenceOrder (Integer, required), isParallel (Boolean, default false), dependencyTaskId (UUID, nullable)
  - [ ] Add validation: sequenceOrder > 0, taskName not blank
  - [ ] Create `backend/src/main/java/com/magnab/employeelifecycle/dto/request/UpdateTemplateRequest.java`
  - [ ] Same structure as CreateTemplateRequest but includes id field
  - [ ] Create `backend/src/main/java/com/magnab/employeelifecycle/dto/response/TemplateSummaryResponse.java`
  - [ ] Add fields: id, name, type, isActive, taskCount (Integer), createdAt, updatedAt
  - [ ] Create `backend/src/main/java/com/magnab/employeelifecycle/dto/response/TemplateDetailResponse.java`
  - [ ] Add fields: id, name, description, type, isActive, tasks (List<TaskDetailResponse>), createdAt, createdBy, updatedAt, updatedBy
  - [ ] Create `backend/src/main/java/com/magnab/employeelifecycle/dto/response/TaskDetailResponse.java`
  - [ ] Add fields: id, taskName, description, assignedRole, sequenceOrder, isParallel, dependencyTaskId, createdAt, updatedAt
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - DTO patterns]

- [ ] **Task 2: Create TemplateController with CRUD endpoints** (AC: 1, 2, 11)
  - [ ] Create `backend/src/main/java/com/magnab/employeelifecycle/controller/TemplateController.java`
  - [ ] Add @RestController and @RequestMapping("/api/templates") annotations
  - [ ] Add @Tag(name = "Templates", description = "Workflow template management") for Swagger
  - [ ] Inject TemplateService via constructor injection (final field)
  - [ ] Add @PreAuthorize("hasAnyRole('HR_ADMIN', 'ADMINISTRATOR')") at class level
  - [ ] Implement POST /api/templates endpoint (createTemplate method)
  - [ ] Implement GET /api/templates endpoint (getAllTemplates method)
  - [ ] Implement GET /api/templates/{id} endpoint (getTemplateById method)
  - [ ] Implement PUT /api/templates/{id} endpoint (updateTemplate method)
  - [ ] Implement DELETE /api/templates/{id} endpoint (deleteTemplate method)
  - [ ] Add @Operation and @ApiResponses annotations for Swagger documentation
  - [ ] Reference: [Source: docs/architecture/rest-api-spec.md - Endpoint patterns]

- [ ] **Task 3: Implement POST /api/templates endpoint** (AC: 1, 3, 9, 10, 11)
  - [ ] Method signature: `ResponseEntity<TemplateDetailResponse> createTemplate(@Valid @RequestBody CreateTemplateRequest request, Authentication auth)`
  - [ ] Extract current user from Authentication object
  - [ ] Call templateService.createTemplate(request, currentUserId)
  - [ ] Return 201 Created with TemplateDetailResponse
  - [ ] Add Swagger annotations: @Operation(summary = "Create new workflow template"), @ApiResponse(201, "Template created"), @ApiResponse(400, "Validation error"), @ApiResponse(403, "Forbidden")
  - [ ] Validate request body with @Valid annotation
  - [ ] Service handles transaction and audit column population
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md]

- [ ] **Task 4: Implement GET /api/templates endpoint** (AC: 1, 4, 11)
  - [ ] Method signature: `ResponseEntity<List<TemplateSummaryResponse>> getAllTemplates()`
  - [ ] Call templateService.getAllTemplates()
  - [ ] Return 200 OK with List<TemplateSummaryResponse>
  - [ ] Add Swagger annotations: @Operation(summary = "Get all workflow templates"), @ApiResponse(200, "Templates retrieved")
  - [ ] Include taskCount in response (calculated from tasks.size())
  - [ ] Reference: [Source: docs/architecture/rest-api-spec.md]

- [ ] **Task 5: Implement GET /api/templates/{id} endpoint** (AC: 1, 5, 11)
  - [ ] Method signature: `ResponseEntity<TemplateDetailResponse> getTemplateById(@PathVariable UUID id)`
  - [ ] Call templateService.getTemplateById(id)
  - [ ] Return 200 OK with TemplateDetailResponse
  - [ ] Add Swagger annotations: @Operation(summary = "Get template by ID"), @ApiResponse(200, "Template found"), @ApiResponse(404, "Template not found")
  - [ ] Service throws ResourceNotFoundException if template not found (handled by GlobalExceptionHandler)
  - [ ] Include complete task list with dependencies
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - 404 handling]

- [ ] **Task 6: Implement PUT /api/templates/{id} endpoint** (AC: 1, 6, 9, 10, 11)
  - [ ] Method signature: `ResponseEntity<TemplateDetailResponse> updateTemplate(@PathVariable UUID id, @Valid @RequestBody UpdateTemplateRequest request, Authentication auth)`
  - [ ] Verify id in path matches id in request body
  - [ ] Extract current user from Authentication
  - [ ] Call templateService.updateTemplate(id, request, currentUserId)
  - [ ] Return 200 OK with updated TemplateDetailResponse
  - [ ] Add Swagger annotations: @Operation(summary = "Update workflow template"), @ApiResponse(200, "Template updated"), @ApiResponse(400, "Validation error"), @ApiResponse(404, "Template not found")
  - [ ] Service handles cascade update to tasks (delete old tasks, create new tasks)
  - [ ] Service updates updated_at and updated_by audit columns
  - [ ] Reference: [Source: docs/architecture/rest-api-spec.md - PUT conventions]

- [ ] **Task 7: Implement DELETE /api/templates/{id} endpoint** (AC: 1, 7, 8, 10, 11)
  - [ ] Method signature: `ResponseEntity<Void> deleteTemplate(@PathVariable UUID id, Authentication auth)`
  - [ ] Extract current user from Authentication
  - [ ] Call templateService.deleteTemplate(id, currentUserId)
  - [ ] Return 204 No Content if successful
  - [ ] Add Swagger annotations: @Operation(summary = "Delete workflow template (soft delete)"), @ApiResponse(204, "Template deleted"), @ApiResponse(404, "Template not found"), @ApiResponse(409, "Template in use by active workflows")
  - [ ] Service checks if template is in use by active workflows (query workflow_instances table)
  - [ ] If in use, service throws ConflictException with message "Template cannot be deleted as it is in use by active workflows"
  - [ ] If not in use, service sets is_active=false and updates updated_by/updated_at
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - 409 Conflict]

- [ ] **Task 8: Create TemplateService with business logic** (AC: 3, 6, 7, 8, 10)
  - [ ] Create `backend/src/main/java/com/magnab/employeelifecycle/service/TemplateService.java`
  - [ ] Add @Service annotation
  - [ ] Add @Transactional annotation at class level
  - [ ] Inject WorkflowTemplateRepository, TemplateTaskRepository, WorkflowInstanceRepository via constructor
  - [ ] Implement createTemplate(CreateTemplateRequest, UUID userId): Convert request DTOs to entities, populate audit columns, save template (cascade saves tasks), return TemplateDetailResponse
  - [ ] Implement getAllTemplates(): Fetch all templates, map to TemplateSummaryResponse with taskCount
  - [ ] Implement getTemplateById(UUID id): Fetch template with tasks (use @EntityGraph to avoid N+1), throw ResourceNotFoundException if not found, map to TemplateDetailResponse
  - [ ] Implement updateTemplate(UUID id, UpdateTemplateRequest, UUID userId): Fetch existing template, delete old tasks, create new tasks from request, update audit columns, save template, return TemplateDetailResponse
  - [ ] Implement deleteTemplate(UUID id, UUID userId): Check if template in use (count active workflows with template_id), throw ConflictException if in use, set is_active=false, update audit columns, save
  - [ ] Add private mapper methods: toEntity(), toDetailResponse(), toSummaryResponse()
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Service layer patterns]

- [ ] **Task 9: Configure SpringDoc OpenAPI** (AC: 11)
  - [ ] Verify `backend/src/main/java/com/magnab/employeelifecycle/config/OpenApiConfig.java` exists (should exist from Story 1.5 or earlier)
  - [ ] If missing, create OpenApiConfig class with @Configuration
  - [ ] Add @Bean for OpenAPI configuration with title "Employee Lifecycle Management API", version "1.0", description
  - [ ] Configure security scheme for session-based authentication
  - [ ] Ensure SpringDoc OpenAPI dependency exists in pom.xml (springdoc-openapi-starter-webmvc-ui version 2.3.0)
  - [ ] Verify Swagger UI accessible at http://localhost:8080/swagger-ui.html
  - [ ] Reference: [Source: docs/architecture/tech-stack.md - SpringDoc OpenAPI 2.3.0]

- [ ] **Task 10: Write integration tests for TemplateController** (AC: 1-11)
  - [ ] Create `backend/src/test/java/com/magnab/employeelifecycle/controller/TemplateControllerIntegrationTest.java`
  - [ ] Add @SpringBootTest, @AutoConfigureMockMvc, @Testcontainers annotations
  - [ ] Set up PostgreSQL TestContainer
  - [ ] Inject MockMvc for API testing
  - [ ] Test POST /api/templates: Create template with tasks, verify 201 response, verify template saved in database
  - [ ] Test GET /api/templates: Verify 200 response, verify list contains created template
  - [ ] Test GET /api/templates/{id}: Verify 200 response, verify complete template details with tasks
  - [ ] Test GET /api/templates/{id} with non-existent ID: Verify 404 response
  - [ ] Test PUT /api/templates/{id}: Update template name and tasks, verify 200 response, verify updates persisted
  - [ ] Test DELETE /api/templates/{id}: Verify 204 response, verify is_active=false in database
  - [ ] Test DELETE /api/templates/{id} when template in use: Create workflow instance using template, attempt delete, verify 409 Conflict response
  - [ ] Test authorization: Attempt access with non-admin role, verify 403 Forbidden
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - Integration testing with TestContainers]

- [ ] **Task 11: Write unit tests for TemplateService** (AC: 3, 6, 7, 8, 10)
  - [ ] Create `backend/src/test/java/com/magnab/employeelifecycle/service/TemplateServiceTest.java`
  - [ ] Add @ExtendWith(MockitoExtension.class) annotation
  - [ ] Mock WorkflowTemplateRepository, TemplateTaskRepository, WorkflowInstanceRepository
  - [ ] Test createTemplate: Verify template and tasks saved, verify audit columns populated
  - [ ] Test getAllTemplates: Verify all templates returned with taskCount calculated
  - [ ] Test getTemplateById with valid ID: Verify template returned with tasks
  - [ ] Test getTemplateById with invalid ID: Verify ResourceNotFoundException thrown
  - [ ] Test updateTemplate: Verify old tasks deleted, new tasks created, audit columns updated
  - [ ] Test deleteTemplate when template not in use: Verify is_active set to false
  - [ ] Test deleteTemplate when template in use: Verify ConflictException thrown with correct message
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - Unit testing with Mockito]

## Dev Notes

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Backend Technologies for Story 2.2:**
- **Framework:** Spring Boot 3.2.2 (Java 17)
- **REST Framework:** Spring Web MVC
- **API Documentation:** SpringDoc OpenAPI 2.3.0
- **Security:** Spring Security 6.2.1
- **Validation:** Jakarta Bean Validation 3.0.2
- **ORM:** Hibernate 6.4.2 (via Spring Data JPA)
- **Testing:** JUnit 5, Mockito 5.8.0, TestContainers 1.19.3

### REST API Design Patterns
[Source: docs/architecture/rest-api-spec.md]

**Base URL:** `http://localhost:8080/api`

**Template Endpoints:**
- `POST /api/templates` - Create new template (201 Created)
- `GET /api/templates` - Get all templates (200 OK with List<TemplateSummaryResponse>)
- `GET /api/templates/{id}` - Get template by ID (200 OK with TemplateDetailResponse)
- `PUT /api/templates/{id}` - Update template (200 OK with TemplateDetailResponse)
- `DELETE /api/templates/{id}` - Soft-delete template (204 No Content)

**Key Design Decisions:**
1. **Session-based auth:** No JWT for MVP simplicity
2. **Role-based access control:** Enforced at endpoint level with @PreAuthorize
3. **No pagination for MVP:** GET /api/templates returns all templates (acceptable for <100 templates)
4. **Consistent error format:** timestamp, status, error, message, path
5. **DTO pattern:** Never expose entities, separate request/response DTOs
6. **Soft delete:** is_active=false preserves template history

### DTO Design
[Source: docs/architecture/coding-standards.md]

**Request DTOs:**
- Use for input validation and API contracts
- Located in `dto/request/` package
- Naming pattern: `{Action}{Entity}Request` (e.g., CreateTemplateRequest)
- Include Jakarta Bean Validation annotations (@NotNull, @NotBlank, @Valid, @Size)
- No Lombok @Data (use @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor)

**Response DTOs:**
- Use for output serialization
- Located in `dto/response/` package
- Naming pattern: `{Entity}{Detail}Response` (e.g., TemplateDetailResponse)
- Summary DTOs for list endpoints (e.g., TemplateSummaryResponse)
- Detail DTOs for single resource endpoints (e.g., TemplateDetailResponse)
- Never include sensitive fields (e.g., password_hash)

**DTO Structure Example:**
```java
// CreateTemplateRequest.java
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CreateTemplateRequest {
    @NotBlank(message = "Template name is required")
    @Size(max = 255, message = "Template name must not exceed 255 characters")
    private String name;

    private String description;

    @NotNull(message = "Template type is required")
    private WorkflowType type;

    @NotNull(message = "Tasks are required")
    @Size(min = 1, message = "Template must have at least one task")
    @Valid
    private List<CreateTemplateTaskRequest> tasks;
}
```

### Security and Authorization
[Source: docs/architecture/security.md]

**Authorization Pattern:**
```java
@RestController
@RequestMapping("/api/templates")
@PreAuthorize("hasAnyRole('HR_ADMIN', 'ADMINISTRATOR')")
public class TemplateController {
    // Only HR_ADMIN and ADMINISTRATOR can access these endpoints
}
```

**Role Enforcement:**
- AC2 requires only HR_ADMIN and ADMINISTRATOR can access template endpoints
- Use `@PreAuthorize("hasAnyRole('HR_ADMIN', 'ADMINISTRATOR')")` at class level
- Spring Security intercepts requests, checks user's role from session
- Returns 403 Forbidden if user lacks required role

**Input Validation:**
- Jakarta Bean Validation (@Valid on request DTOs)
- Validation at API boundary before service layer
- GlobalExceptionHandler catches validation errors, returns 400 Bad Request

**CSRF Protection:**
- Enabled for all non-GET requests (Spring Security default)
- Session-based auth includes CSRF token in responses

### Error Handling
[Source: docs/architecture/error-handling-strategy.md]

**Error Response Format:**
```json
{
  "timestamp": "2025-10-31T10:00:00Z",
  "status": 404,
  "error": "Not Found",
  "message": "Template not found with id: 123e4567-e89b-12d3-a456-426614174000",
  "path": "/api/templates/123e4567-e89b-12d3-a456-426614174000"
}
```

**Custom Exceptions:**
- `ResourceNotFoundException` â†’ 404 Not Found (template not found)
- `ConflictException` â†’ 409 Conflict (template in use by active workflows)
- `ValidationException` â†’ 400 Bad Request (validation errors)
- `ForbiddenException` â†’ 403 Forbidden (user lacks required role)

**GlobalExceptionHandler:**
- Already exists from Story 1.4b (Global Error Handling Middleware)
- Catches all exceptions and returns consistent error responses
- Logs errors with correlation ID for debugging

**Template-Specific Error Scenarios:**
- GET /api/templates/{id} with non-existent ID: ResourceNotFoundException â†’ 404
- DELETE /api/templates/{id} when template in use: ConflictException â†’ 409
- POST /api/templates with invalid data: Validation error â†’ 400
- Access without HR_ADMIN or ADMINISTRATOR role: AccessDeniedException â†’ 403

### Source Tree Structure
[Source: docs/architecture/source-tree.md]

**File Locations for Story 2.2:**
```
backend/src/
â”œâ”€â”€ main/
â”‚   â”œâ”€â”€ java/com/magnab/employeelifecycle/
â”‚   â”‚   â”œâ”€â”€ controller/
â”‚   â”‚   â”‚   â””â”€â”€ TemplateController.java       # CREATE - REST controller
â”‚   â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â”‚   â””â”€â”€ TemplateService.java          # CREATE - Business logic
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”‚   â”œâ”€â”€ request/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CreateTemplateRequest.java       # CREATE - Request DTO
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CreateTemplateTaskRequest.java   # CREATE - Nested request DTO
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ UpdateTemplateRequest.java       # CREATE - Request DTO
â”‚   â”‚   â”‚   â””â”€â”€ response/
â”‚   â”‚   â”‚       â”œâ”€â”€ TemplateSummaryResponse.java     # CREATE - Summary response DTO
â”‚   â”‚   â”‚       â”œâ”€â”€ TemplateDetailResponse.java      # CREATE - Detail response DTO
â”‚   â”‚   â”‚       â””â”€â”€ TaskDetailResponse.java          # CREATE - Nested response DTO
â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â””â”€â”€ OpenApiConfig.java            # VERIFY EXISTS or CREATE
â”‚   â”‚   â””â”€â”€ exception/
â”‚   â”‚       â””â”€â”€ GlobalExceptionHandler.java   # EXISTS from Story 1.4b
â””â”€â”€ test/
    â””â”€â”€ java/com/magnab/employeelifecycle/
        â”œâ”€â”€ controller/
        â”‚   â””â”€â”€ TemplateControllerIntegrationTest.java  # CREATE - Integration tests
        â””â”€â”€ service/
            â””â”€â”€ TemplateServiceTest.java                 # CREATE - Unit tests
```

### Service Layer Patterns
[Source: docs/architecture/coding-standards.md]

**Critical Rules:**
1. **@Transactional at service layer** - All service methods are transactional (class-level annotation)
2. **Constructor injection** - Immutable dependencies (final fields)
3. **DTOs at boundaries** - Services accept request DTOs, return response DTOs, never expose entities
4. **Optional for nullable queries** - Repository methods return Optional<Entity>
5. **Throw specific exceptions** - ResourceNotFoundException, ConflictException (not generic Exception)

**TemplateService Example:**
```java
@Service
@Transactional
public class TemplateService {
    private final WorkflowTemplateRepository templateRepository;
    private final TemplateTaskRepository taskRepository;
    private final WorkflowInstanceRepository workflowInstanceRepository;

    public TemplateService(WorkflowTemplateRepository templateRepository,
                           TemplateTaskRepository taskRepository,
                           WorkflowInstanceRepository workflowInstanceRepository) {
        this.templateRepository = templateRepository;
        this.taskRepository = taskRepository;
        this.workflowInstanceRepository = workflowInstanceRepository;
    }

    public TemplateDetailResponse createTemplate(CreateTemplateRequest request, UUID userId) {
        // Convert DTO to entity
        WorkflowTemplate template = toEntity(request);
        template.setCreatedBy(userId);
        template.setUpdatedBy(userId);

        // Save template (cascade saves tasks)
        WorkflowTemplate saved = templateRepository.save(template);

        // Convert entity to response DTO
        return toDetailResponse(saved);
    }

    public void deleteTemplate(UUID id, UUID userId) {
        // Check if template exists
        WorkflowTemplate template = templateRepository.findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("Template not found with id: " + id));

        // Check if template is in use
        long activeWorkflowCount = workflowInstanceRepository.countByTemplateIdAndStatusNot(id, WorkflowStatus.COMPLETED);
        if (activeWorkflowCount > 0) {
            throw new ConflictException("Template cannot be deleted as it is in use by active workflows");
        }

        // Soft delete
        template.setIsActive(false);
        template.setUpdatedBy(userId);
        template.setUpdatedAt(LocalDateTime.now());
        templateRepository.save(template);
    }
}
```

### Previous Story Context
[Source: docs/stories/2.1.story.md]

**Key Context from Story 2.1:**
- Database schema created: workflow_templates, template_tasks tables
- JPA entities created: WorkflowTemplate, TemplateTask
- Repositories created: WorkflowTemplateRepository, TemplateTaskRepository
- Enums created: WorkflowType (ONBOARDING, OFFBOARDING), WorkflowStatus
- PostgreSQL enum annotation pattern: @JdbcTypeCode(SqlTypes.NAMED_ENUM)
- Foreign key constraints: template_id â†’ workflow_templates (ON DELETE CASCADE)
- Audit columns: created_at, created_by, updated_at, updated_by
- Soft delete: is_active flag on workflow_templates

**Important Note:** This story builds the API layer on top of the database foundation from Story 2.1. The controller will use the repositories and entities created in 2.1.

### MVP Scope Notes
[Source: docs/prd.md - Story 2.2]

**DTOs NOT Included in MVP:**
- ~~CustomFieldDTO~~ ðŸ”® **DEFERRED TO PHASE 2** (Story 2.6)
- ~~ConditionalRuleDTO~~ ðŸ”® **DEFERRED TO PHASE 2** (Story 2.7)

**MVP Approach:** Template DTOs only include name, description, type, tasks. No custom fields or conditional rules. This aligns with database schema from Story 2.1 (custom fields and conditional rules tables deferred).

### Cascade Update Pattern
[Source: docs/architecture/coding-standards.md]

**AC6 requires PUT to cascade updates to tasks (replaces entire structure):**

**Approach:**
1. Fetch existing template by ID
2. Delete all existing tasks (orphanRemoval = true in @OneToMany handles this)
3. Clear template.tasks collection
4. Add new tasks from UpdateTemplateRequest
5. Save template (cascade saves new tasks)

**Implementation:**
```java
public TemplateDetailResponse updateTemplate(UUID id, UpdateTemplateRequest request, UUID userId) {
    // Fetch existing template
    WorkflowTemplate template = templateRepository.findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("Template not found with id: " + id));

    // Update template fields
    template.setName(request.getName());
    template.setDescription(request.getDescription());
    template.setType(request.getType());
    template.setUpdatedBy(userId);
    template.setUpdatedAt(LocalDateTime.now());

    // Replace tasks (clear old, add new)
    template.getTasks().clear();
    for (CreateTemplateTaskRequest taskRequest : request.getTasks()) {
        TemplateTask task = toTaskEntity(taskRequest);
        task.setWorkflowTemplate(template);
        template.getTasks().add(task);
    }

    // Save (cascade updates tasks)
    WorkflowTemplate updated = templateRepository.save(template);

    return toDetailResponse(updated);
}
```

**Important:** JPA orphanRemoval = true in WorkflowTemplate entity's @OneToMany annotation ensures old tasks are deleted when removed from collection.

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**Testing Strategy:** Unit tests for service layer + Integration tests for controller endpoints

**Service Unit Tests (JUnit 5 + Mockito):**
- Test business logic in isolation
- Mock repositories (WorkflowTemplateRepository, TemplateTaskRepository, WorkflowInstanceRepository)
- Test createTemplate, getAllTemplates, getTemplateById, updateTemplate, deleteTemplate
- Test error scenarios: template not found, template in use by workflows
- Verify exception throwing (ResourceNotFoundException, ConflictException)
- Verify audit column population

**Controller Integration Tests (TestContainers):**
- Test complete API flow with real database
- Use MockMvc for HTTP requests
- Test all endpoints: POST, GET, GET by ID, PUT, DELETE
- Test authorization (403 Forbidden for non-admin roles)
- Test error scenarios: 404 for non-existent template, 409 for template in use
- Verify request/response DTOs serialize correctly
- Verify database state after operations

**Manual API Testing:**
- Use Postman or Swagger UI (http://localhost:8080/swagger-ui.html)
- Test all endpoints with various inputs
- Verify Swagger documentation is accurate and complete

**Test File Locations:**
```
backend/src/test/java/com/magnab/employeelifecycle/
â”œâ”€â”€ service/
â”‚   â””â”€â”€ TemplateServiceTest.java          # Unit tests
â””â”€â”€ controller/
    â””â”€â”€ TemplateControllerIntegrationTest.java  # Integration tests
```

**Coverage Goal:** 80% coverage for service and controller layers (per test-strategy.md)

**No Frontend Testing:** This is a backend-only API story, no UI components (frontend will be tested in Stories 2.4 and 2.5)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-31 | 1.0 | Story created from Epic 2 with complete REST API specifications, DTOs, controller endpoints, service layer business logic, and integration tests. MVP scope excludes custom fields and conditional rules DTOs (deferred to Phase 2). | Bob (Scrum Master) |
| 2025-10-31 | 1.1 | Story validated and approved for implementation (Readiness Score: 9.7/10, HIGH confidence, zero hallucinations detected, all 12 technical claims verified against source documents, exceptional code examples provided for DTO structure, security patterns, service layer, and cascade update implementation) | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
