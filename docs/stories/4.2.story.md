# Story 4.2: Task Completion Service with Checklist Validation

## Status
**Approved**

## Story

**As a** backend developer,
**I want** service logic that validates checklist completion before allowing task completion,
**so that** mandatory verification is enforced at the business logic level.

## Acceptance Criteria

1. TaskService.completeTask(taskInstanceId, checklistItems, userId) method processes task completion
2. Method validates that all checklist items have is_checked=true before allowing completion
3. If validation fails, method returns error: "All checklist items must be verified before completion"
4. On successful validation, method persists checklist items to task_checklist_items table with checked_at and checked_by
5. Method copies all checked items to provisioned_items table for offboarding mirror (if workflow type is ONBOARDING)
6. Method updates task_instance status to COMPLETED and sets completed_at and completed_by
7. Method triggers workflow state update (check if all tasks complete â†’ mark workflow COMPLETED)
8. Method triggers assignment of dependent tasks via WorkflowService.assignTasksForWorkflow()
9. All operations occur in single transaction (checklist save + provisioning log + task update + dependent task assignment)
10. Unit tests cover: successful completion, incomplete checklist rejection, offboarding mirror creation, dependent task triggering

## Tasks / Subtasks

- [ ] **Task 1: Create TaskService class** (AC: 1)
  - [ ] Create new file: `backend/src/main/java/com/magnab/employeelifecycle/service/TaskService.java`
  - [ ] Add `@Service` annotation
  - [ ] Use constructor injection for dependencies (final fields):
    - `private final TaskInstanceRepository taskInstanceRepository`
    - `private final TaskChecklistItemRepository taskChecklistItemRepository`
    - `private final ProvisionedItemRepository provisionedItemRepository`
    - `private final WorkflowInstanceRepository workflowInstanceRepository`
    - `private final WorkflowService workflowService`
  - [ ] Add SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(TaskService.class);`
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Use constructor injection]

- [ ] **Task 2: Create ChecklistItemDTO request class** (AC: 1, 4)
  - [ ] Create new file: `backend/src/main/java/com/magnab/employeelifecycle/dto/request/ChecklistItemDTO.java`
  - [ ] Add fields:
    - `private String itemDescription` (required)
    - `private ItemCategory category` (required)
    - `private String itemIdentifier` (optional)
    - `private Boolean isChecked` (required)
  - [ ] Add Jakarta Bean Validation annotations: `@NotNull`, `@NotBlank`
  - [ ] Do NOT use `@Data` Lombok on DTOs (coding standards - use explicit getters/setters or records)
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Lombok for entities only]

- [ ] **Task 3: Create TaskCompletionResponse DTO** (AC: 6)
  - [ ] Create new file: `backend/src/main/java/com/magnab/employeelifecycle/dto/response/TaskCompletionResponse.java`
  - [ ] Add fields:
    - `private UUID taskInstanceId`
    - `private String taskName`
    - `private TaskStatus status` (should be COMPLETED)
    - `private LocalDateTime completedAt`
    - `private UUID completedBy`
    - `private Integer checklistItemsVerified`
    - `private Boolean offboardingMirrorCreated` (true if ONBOARDING workflow)
  - [ ] Use explicit getters/setters or Java record
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Return DTO not entity]

- [ ] **Task 4: Implement completeTask method signature and transaction setup** (AC: 1, 9)
  - [ ] Add method to TaskService: `public TaskCompletionResponse completeTask(UUID taskInstanceId, List<ChecklistItemDTO> checklistItems, UUID userId)`
  - [ ] Add `@Transactional` annotation (all operations must be in single transaction)
  - [ ] Add log statement: `log.info("Completing task {} with {} checklist items", taskInstanceId, checklistItems.size());`
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Transactional at service layer]

- [ ] **Task 5: Validate task instance exists** (AC: 1)
  - [ ] In completeTask method, retrieve task instance: `TaskInstance task = taskInstanceRepository.findById(taskInstanceId).orElseThrow(() -> new ResourceNotFoundException("Task with ID " + taskInstanceId + " not found"));`
  - [ ] Verify task status is IN_PROGRESS: If not, throw `ValidationException("Task must be IN_PROGRESS to be completed. Current status: " + task.getStatus())`
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Specific exceptions not generic]

- [ ] **Task 6: Validate all checklist items are checked** (AC: 2, 3)
  - [ ] Check if ALL checklist items have `isChecked == true`:
    ```java
    boolean allChecked = checklistItems.stream().allMatch(ChecklistItemDTO::getIsChecked);
    if (!allChecked) {
        log.warn("Task completion validation failed: Not all checklist items verified for task {}", taskInstanceId);
        throw new ValidationException("All checklist items must be verified before completion");
    }
    ```
  - [ ] Log validation failure at WARN level
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - ValidationException for 400]

- [ ] **Task 7: Persist checklist items to database** (AC: 4)
  - [ ] Convert ChecklistItemDTOs to TaskChecklistItem entities:
    ```java
    List<TaskChecklistItem> entities = checklistItems.stream()
        .map(dto -> {
            TaskChecklistItem item = new TaskChecklistItem();
            item.setTaskInstanceId(taskInstanceId);
            item.setItemDescription(dto.getItemDescription());
            item.setCategory(dto.getCategory());
            item.setItemIdentifier(dto.getItemIdentifier());
            item.setIsChecked(dto.getIsChecked());
            item.setCheckedAt(LocalDateTime.now());
            item.setCheckedBy(userId);
            return item;
        })
        .toList();
    ```
  - [ ] Save all entities: `taskChecklistItemRepository.saveAll(entities);`
  - [ ] Log: `log.info("Persisted {} checklist items for task {}", entities.size(), taskInstanceId);`
  - [ ] Reference: [Source: Story 4.1 - TaskChecklistItem entity created]

- [ ] **Task 8: Copy checked items to provisioned_items for offboarding mirror** (AC: 5)
  - [ ] Retrieve workflow instance to check workflow type:
    ```java
    WorkflowInstance workflow = workflowInstanceRepository.findById(task.getWorkflowInstanceId())
        .orElseThrow(() -> new ResourceNotFoundException("Workflow not found"));
    ```
  - [ ] If `workflow.getWorkflowType() == WorkflowType.ONBOARDING`:
    - Convert checklist items to ProvisionedItem entities:
      ```java
      List<ProvisionedItem> provisionedItems = checklistItems.stream()
          .map(dto -> {
              ProvisionedItem item = new ProvisionedItem();
              item.setWorkflowInstanceId(workflow.getId());
              item.setTaskInstanceId(taskInstanceId);
              item.setItemDescription(dto.getItemDescription());
              item.setCategory(dto.getCategory());
              item.setItemIdentifier(dto.getItemIdentifier());
              item.setProvisionedAt(LocalDateTime.now());
              item.setProvisionedBy(userId);
              return item;
          })
          .toList();
      ```
    - Save: `provisionedItemRepository.saveAll(provisionedItems);`
    - Log: `log.info("Created {} provisioned items for offboarding mirror", provisionedItems.size());`
  - [ ] If workflow type is OFFBOARDING, skip this step (no mirror creation)
  - [ ] Reference: [Source: PRD Story 4.7 - Offboarding mirror feature]

- [ ] **Task 9: Update task instance to COMPLETED** (AC: 6)
  - [ ] Update task fields:
    - `task.setStatus(TaskStatus.COMPLETED);`
    - `task.setCompletedAt(LocalDateTime.now());`
    - `task.setCompletedBy(userId);`
  - [ ] Save task: `taskInstanceRepository.save(task);`
  - [ ] Log: `log.info("Task {} marked as COMPLETED by user {}", taskInstanceId, userId);`
  - [ ] Reference: [Source: docs/architecture/data-models.md#TaskInstance - completedAt, completedBy fields]

- [ ] **Task 10: Trigger workflow state update** (AC: 7)
  - [ ] Call WorkflowService method to check if all tasks complete:
    ```java
    workflowService.checkAndCompleteWorkflow(workflow.getId(), userId);
    ```
  - [ ] This method (from Story 3.4) checks if all visible tasks are COMPLETED and transitions workflow to COMPLETED if true
  - [ ] Log: `log.debug("Triggered workflow state update for workflow {}", workflow.getId());`
  - [ ] Reference: [Source: Story 3.4 - Workflow State Management]

- [ ] **Task 11: Trigger assignment of dependent tasks** (AC: 8)
  - [ ] Call WorkflowService method to assign tasks that depend on this completed task:
    ```java
    workflowService.assignTasksForWorkflow(workflow.getId());
    ```
  - [ ] This method (from Story 3.3) checks task dependencies and assigns ready tasks to users
  - [ ] Log: `log.debug("Triggered dependent task assignment for workflow {}", workflow.getId());`
  - [ ] Reference: [Source: Story 3.3 - Task Assignment & Routing Logic]

- [ ] **Task 12: Build and return TaskCompletionResponse** (AC: 6)
  - [ ] Create response DTO:
    ```java
    TaskCompletionResponse response = new TaskCompletionResponse();
    response.setTaskInstanceId(task.getId());
    response.setTaskName(task.getTaskName());
    response.setStatus(TaskStatus.COMPLETED);
    response.setCompletedAt(task.getCompletedAt());
    response.setCompletedBy(userId);
    response.setChecklistItemsVerified(checklistItems.size());
    response.setOffboardingMirrorCreated(workflow.getWorkflowType() == WorkflowType.ONBOARDING);
    return response;
    ```
  - [ ] Log: `log.info("Task completion successful for task {}", taskInstanceId);`
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Return DTO not entity]

- [ ] **Task 13: Write unit test for successful task completion** (AC: 10)
  - [ ] Create test file: `backend/src/test/java/com/magnab/employeelifecycle/service/TaskServiceTest.java`
  - [ ] Use `@ExtendWith(MockitoExtension.class)`
  - [ ] Mock dependencies: `@Mock TaskInstanceRepository`, `@Mock TaskChecklistItemRepository`, `@Mock ProvisionedItemRepository`, `@Mock WorkflowInstanceRepository`, `@Mock WorkflowService`
  - [ ] Use `@InjectMocks TaskService taskService`
  - [ ] Test: `completeTask_ValidChecklistAllChecked_CompletesSuccessfully()`
    - Arrange: Mock task IN_PROGRESS, workflow ONBOARDING, 3 checklist items all checked
    - Act: Call `taskService.completeTask(taskId, checklistItems, userId)`
    - Assert: Verify task status COMPLETED, checklist items saved, provisioned items saved, workflow state triggered, dependent tasks assigned
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - JUnit 5 + Mockito]

- [ ] **Task 14: Write unit test for incomplete checklist rejection** (AC: 10)
  - [ ] Test: `completeTask_ChecklistItemNotChecked_ThrowsValidationException()`
    - Arrange: Mock task IN_PROGRESS, checklist with 1 unchecked item (isChecked = false)
    - Act & Assert: Verify `ValidationException` thrown with message "All checklist items must be verified before completion"
    - Verify task status NOT changed, no database writes occurred
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - ValidationException]

- [ ] **Task 15: Write unit test for offboarding mirror creation** (AC: 10)
  - [ ] Test: `completeTask_OnboardingWorkflow_CreatesProvisionedItems()`
    - Arrange: Mock task IN_PROGRESS, workflow type ONBOARDING, 3 checklist items
    - Act: Call `taskService.completeTask()`
    - Assert: Verify `provisionedItemRepository.saveAll()` called with 3 items matching checklist
    - Verify ProvisionedItem fields: workflowInstanceId, taskInstanceId, itemDescription, category, provisionedAt, provisionedBy
  - [ ] Test: `completeTask_OffboardingWorkflow_SkipsProvisionedItems()`
    - Arrange: Workflow type OFFBOARDING
    - Assert: Verify `provisionedItemRepository.saveAll()` NOT called
  - [ ] Reference: [Source: PRD Story 4.7 - Offboarding mirror only for ONBOARDING]

- [ ] **Task 16: Write unit test for dependent task triggering** (AC: 10)
  - [ ] Test: `completeTask_Success_TriggersAssignTasksForWorkflow()`
    - Arrange: Mock task and workflow
    - Act: Call `taskService.completeTask()`
    - Assert: Verify `workflowService.assignTasksForWorkflow(workflowId)` was called
    - This ensures dependent tasks are automatically assigned when prerequisite completes
  - [ ] Reference: [Source: Story 3.3 - assignTasksForWorkflow handles dependencies]

- [ ] **Task 17: Write unit test for workflow completion check** (AC: 10)
  - [ ] Test: `completeTask_Success_TriggersCheckAndCompleteWorkflow()`
    - Arrange: Mock task completion
    - Act: Call `taskService.completeTask()`
    - Assert: Verify `workflowService.checkAndCompleteWorkflow(workflowId, userId)` was called
    - This ensures workflow transitions to COMPLETED when last task finishes
  - [ ] Reference: [Source: Story 3.4 - checkAndCompleteWorkflow transitions workflow]

- [ ] **Task 18: Write unit test for task not found error** (AC: 10)
  - [ ] Test: `completeTask_TaskNotFound_ThrowsResourceNotFoundException()`
    - Arrange: Mock `taskInstanceRepository.findById()` returns empty Optional
    - Act & Assert: Verify `ResourceNotFoundException` thrown
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - ResourceNotFoundException for 404]

- [ ] **Task 19: Write unit test for invalid task status** (AC: 10)
  - [ ] Test: `completeTask_TaskNotInProgress_ThrowsValidationException()`
    - Arrange: Mock task with status NOT_STARTED or COMPLETED
    - Act & Assert: Verify `ValidationException` thrown with message about status requirement
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Specific exceptions]

- [ ] **Task 20: Write integration test for full task completion flow** (AC: 9, 10)
  - [ ] Create test file: `backend/src/test/java/com/magnab/employeelifecycle/service/TaskServiceIntegrationTest.java`
  - [ ] Use `@SpringBootTest` and `@Testcontainers` with PostgreSQL
  - [ ] Test: `completeTask_FullFlow_PersistsAllDataInSingleTransaction()`
    - Arrange: Create real workflow, task, user in test database
    - Act: Call `taskService.completeTask()` with valid checklist
    - Assert: Query database to verify:
      - TaskChecklistItem records created with correct checked_at, checked_by
      - ProvisionedItem records created (if ONBOARDING)
      - TaskInstance status COMPLETED with completedAt, completedBy
      - Workflow state updated if all tasks done
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - TestContainers integration tests]

- [ ] **Task 21: Verify transaction rollback on error** (AC: 9)
  - [ ] Add integration test: `completeTask_ValidationFails_RollsBackTransaction()`
    - Arrange: Create task in database, provide invalid checklist (unchecked item)
    - Act: Call `taskService.completeTask()` expecting ValidationException
    - Assert: Query database to verify NO records created (rollback successful):
      - No TaskChecklistItem records
      - No ProvisionedItem records
      - TaskInstance status still IN_PROGRESS
  - [ ] This verifies `@Transactional` works correctly for all-or-nothing behavior
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Transaction at service layer]

## Dev Notes

### Previous Story Context

**Story 4.1: Task Checklist Data Model (Approved)**
- Created `task_checklist_items` table with columns: id, task_instance_id, item_description, category (ENUM), item_identifier, is_checked, checked_at, checked_by, created_at, updated_at
- Created `provisioned_items` table for offboarding mirror with columns: id, workflow_instance_id, task_instance_id, item_description, category, item_identifier, provisioned_at, provisioned_by
- Created `TaskChecklistItem` JPA entity
- Created `ProvisionedItem` JPA entity (critical for offboarding mirror feature)
- Created `ItemCategory` enum (HARDWARE, SOFTWARE, ACCESS, OTHER)
- Created `TaskChecklistItemRepository` with custom queries
- Created `ProvisionedItemRepository` with custom queries
- All database tables, entities, and repositories ready for use in Story 4.2

**Epic 3 Stories Completed:**
- Story 3.1: Workflow Instance Data Model - created workflow_instances and task_instances tables
- Story 3.2: Workflow Instantiation Service - creates workflow instances from templates
- Story 3.3: Task Assignment & Routing Logic - `WorkflowService.assignTasksForWorkflow()` assigns tasks based on dependencies
- Story 3.4: Workflow State Management - `WorkflowService.checkAndCompleteWorkflow()` transitions workflow to COMPLETED

**Key Dependencies Available:**
- `TaskInstance` entity with status (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED)
- `WorkflowInstance` entity with workflowType (ONBOARDING, OFFBOARDING)
- `WorkflowService.assignTasksForWorkflow(UUID workflowId)` - assigns dependent tasks
- `WorkflowService.checkAndCompleteWorkflow(UUID workflowId, UUID userId)` - completes workflow if all tasks done
- All repositories: TaskInstanceRepository, WorkflowInstanceRepository, TaskChecklistItemRepository, ProvisionedItemRepository

**Integration Points:**
- This story implements the service layer that Story 4.3 (Task Completion API) will call via REST endpoint
- This story creates provisioned_items records that Story 4.7 (Offboarding Mirror) will use to pre-populate offboarding checklists
- This story enforces mandatory verification preventing security risks (orphaned accounts, uncollected equipment)

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Backend Framework:**
- Spring Boot 3.2.2
- Java 17 LTS
- Hibernate 6.4.2 (via Spring Data JPA)
- Maven 3.9.6

**Testing:**
- JUnit 5 (5.10.1) for unit tests
- Mockito 5.8.0 for mocking
- TestContainers 1.19.3 for integration tests with real PostgreSQL 17.2-alpine

**Key Dependencies:**
- Lombok 1.18.30 (entities only - NOT for DTOs)
- Jakarta Bean Validation 3.0.2 for request validation
- SLF4J + Logback for logging

### Service Layer Patterns
[Source: docs/architecture/coding-standards.md]

**Critical Service Rules:**
1. **Constructor Injection:** All dependencies injected via constructor (immutable, final fields)
2. **@Transactional Annotation:** Place on service methods for transaction management (AC #9 requires single transaction)
3. **DTO Usage:** Never expose entities directly, always use DTOs for request/response
4. **Specific Exceptions:** Throw `ValidationException` (400), `ResourceNotFoundException` (404), not generic RuntimeException
5. **Return DTO:** Method returns `TaskCompletionResponse` DTO, not TaskInstance entity
6. **Logger:** Use SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(TaskService.class);`

**Naming Conventions:**
- Service class: `TaskService`
- Method: `completeTask(UUID taskInstanceId, List<ChecklistItemDTO> checklistItems, UUID userId)`
- DTOs: `ChecklistItemDTO` (request), `TaskCompletionResponse` (response)

**Transaction Management:**
- Use `@Transactional` at service layer (not controller)
- Spring will auto-rollback on unchecked exceptions (ValidationException extends RuntimeException)
- All 6 operations must be in single transaction:
  1. Validate checklist items
  2. Persist checklist items to task_checklist_items
  3. Create provisioned items (if ONBOARDING)
  4. Update task status to COMPLETED
  5. Trigger workflow state update
  6. Trigger dependent task assignment

### Data Models
[Source: docs/architecture/data-models.md, Story 4.1]

**TaskChecklistItem Entity (from Story 4.1):**
- Primary key: UUID id
- Foreign key: taskInstanceId (TaskInstance)
- Fields: itemDescription, category (ENUM), itemIdentifier (optional), isChecked (Boolean), checkedAt (Timestamp), checkedBy (User UUID)
- Audit: createdAt, updatedAt

**ProvisionedItem Entity (from Story 4.1):**
- Primary key: UUID id
- Foreign keys: workflowInstanceId (WorkflowInstance), taskInstanceId (TaskInstance), provisionedBy (User UUID)
- Fields: itemDescription, category (ENUM), itemIdentifier (optional), provisionedAt (Timestamp)
- Purpose: Records all items provisioned during ONBOARDING for automatic offboarding mirror

**TaskInstance Entity (from Story 3.1):**
- Primary key: UUID id
- Foreign keys: workflowInstanceId (WorkflowInstance), assignedUserId (User, nullable), completedBy (User, nullable)
- Status: Enum (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED)
- Completion fields: completedAt (Timestamp, nullable), completedBy (UUID, nullable)

**WorkflowInstance Entity (from Story 3.1):**
- Primary key: UUID id
- workflowType: Enum (ONBOARDING, OFFBOARDING)
- Status: Enum (INITIATED, IN_PROGRESS, BLOCKED, COMPLETED)

### Error Handling
[Source: docs/architecture/error-handling-strategy.md]

**Custom Exceptions to Use:**
- `ResourceNotFoundException` - Task not found (404)
- `ValidationException` - Checklist validation fails, invalid task status (400)

**Error Messages:**
- "Task with ID {id} not found"
- "All checklist items must be verified before completion"
- "Task must be IN_PROGRESS to be completed. Current status: {status}"

**Logging Standards:**
- Use SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(TaskService.class);`
- Log levels:
  - ERROR: Unexpected exceptions
  - WARN: Validation failures (incomplete checklist)
  - INFO: Task completion success, checklist items persisted, offboarding mirror created
  - DEBUG: Workflow state trigger, dependent task assignment trigger
- Never log sensitive data (passwords, PII)

**Service Error Handling:**
- If task not found: throw ResourceNotFoundException
- If checklist validation fails: throw ValidationException
- If task status not IN_PROGRESS: throw ValidationException
- Transaction auto-rolls back on unchecked exceptions

### File Locations
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
```
backend/src/
â”œâ”€â”€ main/java/com/magnab/employeelifecycle/
â”‚   â”œâ”€â”€ service/
â”‚   â”‚   â””â”€â”€ TaskService.java                          # CREATE - Service class
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”œâ”€â”€ request/
â”‚   â”‚   â”‚   â””â”€â”€ ChecklistItemDTO.java                 # CREATE - Request DTO
â”‚   â”‚   â””â”€â”€ response/
â”‚   â”‚       â””â”€â”€ TaskCompletionResponse.java           # CREATE - Response DTO
â””â”€â”€ test/java/com/magnab/employeelifecycle/
    â””â”€â”€ service/
        â”œâ”€â”€ TaskServiceTest.java                      # CREATE - Unit tests
        â””â”€â”€ TaskServiceIntegrationTest.java           # CREATE - Integration tests
```

**Existing Files to Reference (DO NOT MODIFY unless needed):**
- Entity classes: TaskInstance, WorkflowInstance, TaskChecklistItem, ProvisionedItem, User (from previous stories)
- Repository interfaces: TaskInstanceRepository, WorkflowInstanceRepository, TaskChecklistItemRepository, ProvisionedItemRepository
- Service classes: WorkflowService (provides assignTasksForWorkflow() and checkAndCompleteWorkflow() methods)
- Enum classes: TaskStatus, WorkflowType, ItemCategory
- Exception classes: ResourceNotFoundException, ValidationException

### Business Logic - Offboarding Mirror
[Source: PRD Story 4.7, Story 4.1 Dev Notes]

**Critical Security Feature:**
The `completeTask` method implements the foundation for the "offboarding mirror" feature - a key differentiator of this system.

**How it Works:**
1. When a task is completed during ONBOARDING, all verified checklist items are persisted to `task_checklist_items` table
2. The same items are ALSO copied to `provisioned_items` table (AC #5)
3. During offboarding (Story 4.7), the system will query `provisioned_items` by employee and pre-populate offboarding task checklists
4. This ensures perfect symmetry: everything provisioned during onboarding is automatically deprovisioned during offboarding

**Why This Matters:**
- Current manual process results in forgotten accounts (MS 365, GitHub, SharePoint, Teams) and uncollected equipment
- Automated mirror ensures 100% coverage - eliminates orphaned accounts and security risks
- Category field enables smart routing (ACCESS items â†’ account deprovisioning task, HARDWARE items â†’ equipment collection task)

**Implementation Details:**
- Only create provisioned items if `workflow.getWorkflowType() == WorkflowType.ONBOARDING`
- For OFFBOARDING workflows, skip provisioned item creation (these workflows CONSUME provisioned items created during onboarding)
- Each ProvisionedItem must include: workflowInstanceId, taskInstanceId, itemDescription, category, itemIdentifier, provisionedAt, provisionedBy
- Log creation: `log.info("Created {} provisioned items for offboarding mirror", count);`

### Integration with WorkflowService
[Source: Story 3.3, Story 3.4]

**WorkflowService.assignTasksForWorkflow(UUID workflowId):**
- Purpose: Assigns tasks that are ready (dependencies satisfied, visible)
- Called from `completeTask` after task marked COMPLETED (AC #8)
- Automatically assigns dependent tasks when prerequisite task completes
- Example: If Task A depends on Task B, completing Task B triggers assignment of Task A

**WorkflowService.checkAndCompleteWorkflow(UUID workflowId, UUID userId):**
- Purpose: Checks if all visible tasks are COMPLETED, transitions workflow to COMPLETED if true
- Called from `completeTask` after task status updated (AC #7)
- Updates workflow status from IN_PROGRESS â†’ COMPLETED
- Records state change in workflow_state_history table

**Why These Calls Matter:**
- Automatic workflow progression without manual intervention
- Dependent tasks get assigned immediately when prerequisites complete
- Workflow completes automatically when last task finishes
- All in single transaction with task completion (AC #9)

### Project Structure Alignment
[Source: docs/architecture/source-tree.md]

All file paths align with the defined source tree structure:
- Service in `backend/src/main/java/com/magnab/employeelifecycle/service/`
- Request DTOs in `backend/src/main/java/com/magnab/employeelifecycle/dto/request/`
- Response DTOs in `backend/src/main/java/com/magnab/employeelifecycle/dto/response/`
- Unit tests in `backend/src/test/java/com/magnab/employeelifecycle/service/`

No structural conflicts or deviations from architecture guidelines.

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**Unit Tests (JUnit 5 + Mockito):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/service/TaskServiceTest.java`
- Use `@ExtendWith(MockitoExtension.class)`
- Mock all repository and service dependencies with `@Mock`
- Inject TaskService with `@InjectMocks`
- Coverage goal: 80% for service layer

**Test Scenarios (AC #10 requires these tests):**
1. âœ… Successful task completion (all checklist items checked)
2. âœ… Validation failure (checklist item not checked)
3. âœ… Offboarding mirror creation (ONBOARDING workflow)
4. âœ… Offboarding mirror skipped (OFFBOARDING workflow)
5. âœ… Dependent task assignment triggered
6. âœ… Workflow completion check triggered
7. âœ… Task not found error
8. âœ… Invalid task status error (NOT_STARTED, COMPLETED)

**Integration Tests (TestContainers):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/service/TaskServiceIntegrationTest.java`
- Use `@SpringBootTest` and `@Testcontainers`
- Real PostgreSQL 17.2-alpine container
- Verify database state after task completion
- Test transaction rollback on validation failure

**Example Unit Test Structure:**
```java
@ExtendWith(MockitoExtension.class)
class TaskServiceTest {
    @Mock private TaskInstanceRepository taskInstanceRepository;
    @Mock private TaskChecklistItemRepository taskChecklistItemRepository;
    @Mock private ProvisionedItemRepository provisionedItemRepository;
    @Mock private WorkflowInstanceRepository workflowInstanceRepository;
    @Mock private WorkflowService workflowService;

    @InjectMocks
    private TaskService taskService;

    @Test
    void completeTask_ValidChecklistAllChecked_CompletesSuccessfully() {
        // Arrange: Mock task IN_PROGRESS, workflow ONBOARDING, checklist all checked
        UUID taskId = UUID.randomUUID();
        UUID userId = UUID.randomUUID();
        TaskInstance task = new TaskInstance();
        task.setId(taskId);
        task.setStatus(TaskStatus.IN_PROGRESS);
        task.setWorkflowInstanceId(UUID.randomUUID());

        WorkflowInstance workflow = new WorkflowInstance();
        workflow.setWorkflowType(WorkflowType.ONBOARDING);

        List<ChecklistItemDTO> checklistItems = List.of(
            new ChecklistItemDTO("Laptop Dell XPS", ItemCategory.HARDWARE, "SN123456", true),
            new ChecklistItemDTO("MS 365 License", ItemCategory.SOFTWARE, "LIC789", true)
        );

        when(taskInstanceRepository.findById(taskId)).thenReturn(Optional.of(task));
        when(workflowInstanceRepository.findById(task.getWorkflowInstanceId())).thenReturn(Optional.of(workflow));

        // Act
        TaskCompletionResponse response = taskService.completeTask(taskId, checklistItems, userId);

        // Assert
        verify(taskChecklistItemRepository).saveAll(argThat(items -> items.size() == 2));
        verify(provisionedItemRepository).saveAll(argThat(items -> items.size() == 2)); // Offboarding mirror
        verify(taskInstanceRepository).save(argThat(t -> t.getStatus() == TaskStatus.COMPLETED));
        verify(workflowService).checkAndCompleteWorkflow(workflow.getId(), userId);
        verify(workflowService).assignTasksForWorkflow(workflow.getId());

        assertEquals(TaskStatus.COMPLETED, response.getStatus());
        assertEquals(2, response.getChecklistItemsVerified());
        assertTrue(response.getOffboardingMirrorCreated());
    }

    @Test
    void completeTask_ChecklistItemNotChecked_ThrowsValidationException() {
        // Arrange: Checklist with 1 unchecked item
        UUID taskId = UUID.randomUUID();
        TaskInstance task = new TaskInstance();
        task.setStatus(TaskStatus.IN_PROGRESS);

        List<ChecklistItemDTO> checklistItems = List.of(
            new ChecklistItemDTO("Item 1", ItemCategory.HARDWARE, null, true),
            new ChecklistItemDTO("Item 2", ItemCategory.SOFTWARE, null, false) // NOT CHECKED!
        );

        when(taskInstanceRepository.findById(taskId)).thenReturn(Optional.of(task));

        // Act & Assert
        ValidationException ex = assertThrows(ValidationException.class, () -> {
            taskService.completeTask(taskId, checklistItems, userId);
        });

        assertEquals("All checklist items must be verified before completion", ex.getMessage());
        verify(taskChecklistItemRepository, never()).saveAll(any());
        verify(provisionedItemRepository, never()).saveAll(any());
    }
}
```

**Coverage Verification:**
- Run: `mvn test jacoco:report`
- Check: `backend/target/site/jacoco/index.html`
- Goal: 80% coverage for TaskService class

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-31 | 1.1 | Story validated and approved. Comprehensive validation completed: template compliance verified, all 10 ACs covered with 100% task mapping, anti-hallucination verification passed (30+ source references validated), implementation readiness confirmed (10/10 score). Complete service implementation with exact Java code provided. 9 unit tests + 2 integration tests specified. Zero critical issues found. Status updated from Draft to Approved. | Sarah (Product Owner) |
| 2025-10-31 | 1.0 | Story created from Epic 4 with complete service layer specification for task completion with mandatory checklist validation. Implements critical offboarding mirror feature by copying verified items to provisioned_items table. Includes transaction management, workflow progression triggers, comprehensive unit and integration testing requirements. Foundation for Task Completion API (Story 4.3) and Offboarding Mirror (Story 4.7). | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
