# Story 4.2: Task Completion Service with Checklist Validation

## Status
**Approved**

## Story

**As a** backend developer,
**I want** service logic that validates checklist completion before allowing task completion,
**so that** mandatory verification is enforced at the business logic level.

## Acceptance Criteria

1. TaskService.completeTask(taskInstanceId, checklistItems, userId) method processes task completion
2. Method validates that all checklist items have is_checked=true before allowing completion
3. If validation fails, method returns error: "All checklist items must be verified before completion"
4. On successful validation, method persists checklist items to task_checklist_items table with checked_at and checked_by
5. Method copies all checked items to provisioned_items table for offboarding mirror (if workflow type is ONBOARDING)
6. Method updates task_instance status to COMPLETED and sets completed_at and completed_by
7. Method triggers workflow state update (check if all tasks complete → mark workflow COMPLETED)
8. Method triggers assignment of dependent tasks via WorkflowService.assignTasksForWorkflow()
9. All operations occur in single transaction (checklist save + provisioning log + task update + dependent task assignment)
10. Unit tests cover: successful completion, incomplete checklist rejection, offboarding mirror creation, dependent task triggering

## Tasks / Subtasks

- [ ] **Task 1: Create TaskService class** (AC: 1)
  - [ ] Create new file: `backend/src/main/java/com/magnab/employeelifecycle/service/TaskService.java`
  - [ ] Add `@Service` annotation
  - [ ] Use constructor injection for dependencies (final fields):
    - `private final TaskInstanceRepository taskInstanceRepository`
    - `private final TaskChecklistItemRepository taskChecklistItemRepository`
    - `private final ProvisionedItemRepository provisionedItemRepository`
    - `private final WorkflowInstanceRepository workflowInstanceRepository`
    - `private final WorkflowService workflowService`
  - [ ] Add SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(TaskService.class);`
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Use constructor injection]

- [ ] **Task 2: Create ChecklistItemDTO request class** (AC: 1, 4)
  - [ ] Create new file: `backend/src/main/java/com/magnab/employeelifecycle/dto/request/ChecklistItemDTO.java`
  - [ ] Add fields:
    - `private String itemDescription` (required)
    - `private ItemCategory category` (required)
    - `private String itemIdentifier` (optional)
    - `private Boolean isChecked` (required)
  - [ ] Add Jakarta Bean Validation annotations: `@NotNull`, `@NotBlank`
  - [ ] Do NOT use `@Data` Lombok on DTOs (coding standards - use explicit getters/setters or records)
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Lombok for entities only]

- [ ] **Task 3: Create TaskCompletionResponse DTO** (AC: 6)
  - [ ] Create new file: `backend/src/main/java/com/magnab/employeelifecycle/dto/response/TaskCompletionResponse.java`
  - [ ] Add fields:
    - `private UUID taskInstanceId`
    - `private String taskName`
    - `private TaskStatus status` (should be COMPLETED)
    - `private LocalDateTime completedAt`
    - `private UUID completedBy`
    - `private Integer checklistItemsVerified`
    - `private Boolean offboardingMirrorCreated` (true if ONBOARDING workflow)
  - [ ] Use explicit getters/setters or Java record
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Return DTO not entity]

- [ ] **Task 4: Implement completeTask method signature and transaction setup** (AC: 1, 9)
  - [ ] Add method to TaskService: `public TaskCompletionResponse completeTask(UUID taskInstanceId, List<ChecklistItemDTO> checklistItems, UUID userId)`
  - [ ] Add `@Transactional` annotation (all operations must be in single transaction)
  - [ ] Add log statement: `log.info("Completing task {} with {} checklist items", taskInstanceId, checklistItems.size());`
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Transactional at service layer]

- [ ] **Task 5: Validate task instance exists** (AC: 1)
  - [ ] In completeTask method, retrieve task instance: `TaskInstance task = taskInstanceRepository.findById(taskInstanceId).orElseThrow(() -> new ResourceNotFoundException("Task with ID " + taskInstanceId + " not found"));`
  - [ ] Verify task status is IN_PROGRESS: If not, throw `ValidationException("Task must be IN_PROGRESS to be completed. Current status: " + task.getStatus())`
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Specific exceptions not generic]

- [ ] **Task 6: Validate all checklist items are checked** (AC: 2, 3)
  - [ ] Check if ALL checklist items have `isChecked == true`:
    ```java
    boolean allChecked = checklistItems.stream().allMatch(ChecklistItemDTO::getIsChecked);
    if (!allChecked) {
        log.warn("Task completion validation failed: Not all checklist items verified for task {}", taskInstanceId);
        throw new ValidationException("All checklist items must be verified before completion");
    }
    ```
  - [ ] Log validation failure at WARN level
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - ValidationException for 400]

- [ ] **Task 7: Persist checklist items to database** (AC: 4)
  - [ ] Convert ChecklistItemDTOs to TaskChecklistItem entities:
    ```java
    List<TaskChecklistItem> entities = checklistItems.stream()
        .map(dto -> {
            TaskChecklistItem item = new TaskChecklistItem();
            item.setTaskInstanceId(taskInstanceId);
            item.setItemDescription(dto.getItemDescription());
            item.setCategory(dto.getCategory());
            item.setItemIdentifier(dto.getItemIdentifier());
            item.setIsChecked(dto.getIsChecked());
            item.setCheckedAt(LocalDateTime.now());
            item.setCheckedBy(userId);
            return item;
        })
        .toList();
    ```
  - [ ] Save all entities: `taskChecklistItemRepository.saveAll(entities);`
  - [ ] Log: `log.info("Persisted {} checklist items for task {}", entities.size(), taskInstanceId);`
  - [ ] Reference: [Source: Story 4.1 - TaskChecklistItem entity created]

- [ ] **Task 8: Copy checked items to provisioned_items for offboarding mirror** (AC: 5)
  - [ ] Retrieve workflow instance to check workflow type:
    ```java
    WorkflowInstance workflow = workflowInstanceRepository.findById(task.getWorkflowInstanceId())
        .orElseThrow(() -> new ResourceNotFoundException("Workflow not found"));
    ```
  - [ ] If `workflow.getWorkflowType() == WorkflowType.ONBOARDING`:
    - Convert checklist items to ProvisionedItem entities:
      ```java
      List<ProvisionedItem> provisionedItems = checklistItems.stream()
          .map(dto -> {
              ProvisionedItem item = new ProvisionedItem();
              item.setWorkflowInstanceId(workflow.getId());
              item.setTaskInstanceId(taskInstanceId);
              item.setItemDescription(dto.getItemDescription());
              item.setCategory(dto.getCategory());
              item.setItemIdentifier(dto.getItemIdentifier());
              item.setProvisionedAt(LocalDateTime.now());
              item.setProvisionedBy(userId);
              return item;
          })
          .toList();
      ```
    - Save: `provisionedItemRepository.saveAll(provisionedItems);`
    - Log: `log.info("Created {} provisioned items for offboarding mirror", provisionedItems.size());`
  - [ ] If workflow type is OFFBOARDING, skip this step (no mirror creation)
  - [ ] Reference: [Source: PRD Story 4.7 - Offboarding mirror feature]

- [ ] **Task 9: Update task instance to COMPLETED** (AC: 6)
  - [ ] Update task fields:
    - `task.setStatus(TaskStatus.COMPLETED);`
    - `task.setCompletedAt(LocalDateTime.now());`
    - `task.setCompletedBy(userId);`
  - [ ] Save task: `taskInstanceRepository.save(task);`
  - [ ] Log: `log.info("Task {} marked as COMPLETED by user {}", taskInstanceId, userId);`
  - [ ] Reference: [Source: docs/architecture/data-models.md#TaskInstance - completedAt, completedBy fields]

- [ ] **Task 10: Trigger workflow state update** (AC: 7)
  - [ ] Call WorkflowService method to check if all tasks complete:
    ```java
    workflowService.checkAndCompleteWorkflow(workflow.getId(), userId);
    ```
  - [ ] This method (from Story 3.4) checks if all visible tasks are COMPLETED and transitions workflow to COMPLETED if true
  - [ ] Log: `log.debug("Triggered workflow state update for workflow {}", workflow.getId());`
  - [ ] Reference: [Source: Story 3.4 - Workflow State Management]

- [ ] **Task 11: Trigger assignment of dependent tasks** (AC: 8)
  - [ ] Call WorkflowService method to assign tasks that depend on this completed task:
    ```java
    workflowService.assignTasksForWorkflow(workflow.getId());
    ```
  - [ ] This method (from Story 3.3) checks task dependencies and assigns ready tasks to users
  - [ ] Log: `log.debug("Triggered dependent task assignment for workflow {}", workflow.getId());`
  - [ ] Reference: [Source: Story 3.3 - Task Assignment & Routing Logic]

- [ ] **Task 12: Build and return TaskCompletionResponse** (AC: 6)
  - [ ] Create response DTO:
    ```java
    TaskCompletionResponse response = new TaskCompletionResponse();
    response.setTaskInstanceId(task.getId());
    response.setTaskName(task.getTaskName());
    response.setStatus(TaskStatus.COMPLETED);
    response.setCompletedAt(task.getCompletedAt());
    response.setCompletedBy(userId);
    response.setChecklistItemsVerified(checklistItems.size());
    response.setOffboardingMirrorCreated(workflow.getWorkflowType() == WorkflowType.ONBOARDING);
    return response;
    ```
  - [ ] Log: `log.info("Task completion successful for task {}", taskInstanceId);`
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Return DTO not entity]

- [ ] **Task 13: Write unit test for successful task completion** (AC: 10)
  - [ ] Create test file: `backend/src/test/java/com/magnab/employeelifecycle/service/TaskServiceTest.java`
  - [ ] Use `@ExtendWith(MockitoExtension.class)`
  - [ ] Mock dependencies: `@Mock TaskInstanceRepository`, `@Mock TaskChecklistItemRepository`, `@Mock ProvisionedItemRepository`, `@Mock WorkflowInstanceRepository`, `@Mock WorkflowService`
  - [ ] Use `@InjectMocks TaskService taskService`
  - [ ] Test: `completeTask_ValidChecklistAllChecked_CompletesSuccessfully()`
    - Arrange: Mock task IN_PROGRESS, workflow ONBOARDING, 3 checklist items all checked
    - Act: Call `taskService.completeTask(taskId, checklistItems, userId)`
    - Assert: Verify task status COMPLETED, checklist items saved, provisioned items saved, workflow state triggered, dependent tasks assigned
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - JUnit 5 + Mockito]

- [ ] **Task 14: Write unit test for incomplete checklist rejection** (AC: 10)
  - [ ] Test: `completeTask_ChecklistItemNotChecked_ThrowsValidationException()`
    - Arrange: Mock task IN_PROGRESS, checklist with 1 unchecked item (isChecked = false)
    - Act & Assert: Verify `ValidationException` thrown with message "All checklist items must be verified before completion"
    - Verify task status NOT changed, no database writes occurred
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - ValidationException]

- [ ] **Task 15: Write unit test for offboarding mirror creation** (AC: 10)
  - [ ] Test: `completeTask_OnboardingWorkflow_CreatesProvisionedItems()`
    - Arrange: Mock task IN_PROGRESS, workflow type ONBOARDING, 3 checklist items
    - Act: Call `taskService.completeTask()`
    - Assert: Verify `provisionedItemRepository.saveAll()` called with 3 items matching checklist
    - Verify ProvisionedItem fields: workflowInstanceId, taskInstanceId, itemDescription, category, provisionedAt, provisionedBy
  - [ ] Test: `completeTask_OffboardingWorkflow_SkipsProvisionedItems()`
    - Arrange: Workflow type OFFBOARDING
    - Assert: Verify `provisionedItemRepository.saveAll()` NOT called
  - [ ] Reference: [Source: PRD Story 4.7 - Offboarding mirror only for ONBOARDING]

- [ ] **Task 16: Write unit test for dependent task triggering** (AC: 10)
  - [ ] Test: `completeTask_Success_TriggersAssignTasksForWorkflow()`
    - Arrange: Mock task and workflow
    - Act: Call `taskService.completeTask()`
    - Assert: Verify `workflowService.assignTasksForWorkflow(workflowId)` was called
    - This ensures dependent tasks are automatically assigned when prerequisite completes
  - [ ] Reference: [Source: Story 3.3 - assignTasksForWorkflow handles dependencies]

- [ ] **Task 17: Write unit test for workflow completion check** (AC: 10)
  - [ ] Test: `completeTask_Success_TriggersCheckAndCompleteWorkflow()`
    - Arrange: Mock task completion
    - Act: Call `taskService.completeTask()`
    - Assert: Verify `workflowService.checkAndCompleteWorkflow(workflowId, userId)` was called
    - This ensures workflow transitions to COMPLETED when last task finishes
  - [ ] Reference: [Source: Story 3.4 - checkAndCompleteWorkflow transitions workflow]

- [ ] **Task 18: Write unit test for task not found error** (AC: 10)
  - [ ] Test: `completeTask_TaskNotFound_ThrowsResourceNotFoundException()`
    - Arrange: Mock `taskInstanceRepository.findById()` returns empty Optional
    - Act & Assert: Verify `ResourceNotFoundException` thrown
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - ResourceNotFoundException for 404]

- [ ] **Task 19: Write unit test for invalid task status** (AC: 10)
  - [ ] Test: `completeTask_TaskNotInProgress_ThrowsValidationException()`
    - Arrange: Mock task with status NOT_STARTED or COMPLETED
    - Act & Assert: Verify `ValidationException` thrown with message about status requirement
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Specific exceptions]

- [ ] **Task 20: Write integration test for full task completion flow** (AC: 9, 10)
  - [ ] Create test file: `backend/src/test/java/com/magnab/employeelifecycle/service/TaskServiceIntegrationTest.java`
  - [ ] Use `@SpringBootTest` and `@Testcontainers` with PostgreSQL
  - [ ] Test: `completeTask_FullFlow_PersistsAllDataInSingleTransaction()`
    - Arrange: Create real workflow, task, user in test database
    - Act: Call `taskService.completeTask()` with valid checklist
    - Assert: Query database to verify:
      - TaskChecklistItem records created with correct checked_at, checked_by
      - ProvisionedItem records created (if ONBOARDING)
      - TaskInstance status COMPLETED with completedAt, completedBy
      - Workflow state updated if all tasks done
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - TestContainers integration tests]

- [ ] **Task 21: Verify transaction rollback on error** (AC: 9)
  - [ ] Add integration test: `completeTask_ValidationFails_RollsBackTransaction()`
    - Arrange: Create task in database, provide invalid checklist (unchecked item)
    - Act: Call `taskService.completeTask()` expecting ValidationException
    - Assert: Query database to verify NO records created (rollback successful):
      - No TaskChecklistItem records
      - No ProvisionedItem records
      - TaskInstance status still IN_PROGRESS
  - [ ] This verifies `@Transactional` works correctly for all-or-nothing behavior
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Transaction at service layer]

## Dev Notes

### Previous Story Context

**Story 4.1: Task Checklist Data Model (Approved)**
- Created `task_checklist_items` table with columns: id, task_instance_id, item_description, category (ENUM), item_identifier, is_checked, checked_at, checked_by, created_at, updated_at
- Created `provisioned_items` table for offboarding mirror with columns: id, workflow_instance_id, task_instance_id, item_description, category, item_identifier, provisioned_at, provisioned_by
- Created `TaskChecklistItem` JPA entity
- Created `ProvisionedItem` JPA entity (critical for offboarding mirror feature)
- Created `ItemCategory` enum (HARDWARE, SOFTWARE, ACCESS, OTHER)
- Created `TaskChecklistItemRepository` with custom queries
- Created `ProvisionedItemRepository` with custom queries
- All database tables, entities, and repositories ready for use in Story 4.2

**Epic 3 Stories Completed:**
- Story 3.1: Workflow Instance Data Model - created workflow_instances and task_instances tables
- Story 3.2: Workflow Instantiation Service - creates workflow instances from templates
- Story 3.3: Task Assignment & Routing Logic - `WorkflowService.assignTasksForWorkflow()` assigns tasks based on dependencies
- Story 3.4: Workflow State Management - `WorkflowService.checkAndCompleteWorkflow()` transitions workflow to COMPLETED

**Key Dependencies Available:**
- `TaskInstance` entity with status (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED)
- `WorkflowInstance` entity with workflowType (ONBOARDING, OFFBOARDING)
- `WorkflowService.assignTasksForWorkflow(UUID workflowId)` - assigns dependent tasks
- `WorkflowService.checkAndCompleteWorkflow(UUID workflowId, UUID userId)` - completes workflow if all tasks done
- All repositories: TaskInstanceRepository, WorkflowInstanceRepository, TaskChecklistItemRepository, ProvisionedItemRepository

**Integration Points:**
- This story implements the service layer that Story 4.3 (Task Completion API) will call via REST endpoint
- This story creates provisioned_items records that Story 4.7 (Offboarding Mirror) will use to pre-populate offboarding checklists
- This story enforces mandatory verification preventing security risks (orphaned accounts, uncollected equipment)

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Backend Framework:**
- Spring Boot 3.2.2
- Java 17 LTS
- Hibernate 6.4.2 (via Spring Data JPA)
- Maven 3.9.6

**Testing:**
- JUnit 5 (5.10.1) for unit tests
- Mockito 5.8.0 for mocking
- TestContainers 1.19.3 for integration tests with real PostgreSQL 17.2-alpine

**Key Dependencies:**
- Lombok 1.18.30 (entities only - NOT for DTOs)
- Jakarta Bean Validation 3.0.2 for request validation
- SLF4J + Logback for logging

### Service Layer Patterns
[Source: docs/architecture/coding-standards.md]

**Critical Service Rules:**
1. **Constructor Injection:** All dependencies injected via constructor (immutable, final fields)
2. **@Transactional Annotation:** Place on service methods for transaction management (AC #9 requires single transaction)
3. **DTO Usage:** Never expose entities directly, always use DTOs for request/response
4. **Specific Exceptions:** Throw `ValidationException` (400), `ResourceNotFoundException` (404), not generic RuntimeException
5. **Return DTO:** Method returns `TaskCompletionResponse` DTO, not TaskInstance entity
6. **Logger:** Use SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(TaskService.class);`

**Naming Conventions:**
- Service class: `TaskService`
- Method: `completeTask(UUID taskInstanceId, List<ChecklistItemDTO> checklistItems, UUID userId)`
- DTOs: `ChecklistItemDTO` (request), `TaskCompletionResponse` (response)

**Transaction Management:**
- Use `@Transactional` at service layer (not controller)
- Spring will auto-rollback on unchecked exceptions (ValidationException extends RuntimeException)
- All 6 operations must be in single transaction:
  1. Validate checklist items
  2. Persist checklist items to task_checklist_items
  3. Create provisioned items (if ONBOARDING)
  4. Update task status to COMPLETED
  5. Trigger workflow state update
  6. Trigger dependent task assignment

### Data Models
[Source: docs/architecture/data-models.md, Story 4.1]

**TaskChecklistItem Entity (from Story 4.1):**
- Primary key: UUID id
- Foreign key: taskInstanceId (TaskInstance)
- Fields: itemDescription, category (ENUM), itemIdentifier (optional), isChecked (Boolean), checkedAt (Timestamp), checkedBy (User UUID)
- Audit: createdAt, updatedAt

**ProvisionedItem Entity (from Story 4.1):**
- Primary key: UUID id
- Foreign keys: workflowInstanceId (WorkflowInstance), taskInstanceId (TaskInstance), provisionedBy (User UUID)
- Fields: itemDescription, category (ENUM), itemIdentifier (optional), provisionedAt (Timestamp)
- Purpose: Records all items provisioned during ONBOARDING for automatic offboarding mirror

**TaskInstance Entity (from Story 3.1):**
- Primary key: UUID id
- Foreign keys: workflowInstanceId (WorkflowInstance), assignedUserId (User, nullable), completedBy (User, nullable)
- Status: Enum (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED)
- Completion fields: completedAt (Timestamp, nullable), completedBy (UUID, nullable)

**WorkflowInstance Entity (from Story 3.1):**
- Primary key: UUID id
- workflowType: Enum (ONBOARDING, OFFBOARDING)
- Status: Enum (INITIATED, IN_PROGRESS, BLOCKED, COMPLETED)

### Error Handling
[Source: docs/architecture/error-handling-strategy.md]

**Custom Exceptions to Use:**
- `ResourceNotFoundException` - Task not found (404)
- `ValidationException` - Checklist validation fails, invalid task status (400)

**Error Messages:**
- "Task with ID {id} not found"
- "All checklist items must be verified before completion"
- "Task must be IN_PROGRESS to be completed. Current status: {status}"

**Logging Standards:**
- Use SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(TaskService.class);`
- Log levels:
  - ERROR: Unexpected exceptions
  - WARN: Validation failures (incomplete checklist)
  - INFO: Task completion success, checklist items persisted, offboarding mirror created
  - DEBUG: Workflow state trigger, dependent task assignment trigger
- Never log sensitive data (passwords, PII)

**Service Error Handling:**
- If task not found: throw ResourceNotFoundException
- If checklist validation fails: throw ValidationException
- If task status not IN_PROGRESS: throw ValidationException
- Transaction auto-rolls back on unchecked exceptions

### File Locations
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
```
backend/src/
├── main/java/com/magnab/employeelifecycle/
│   ├── service/
│   │   └── TaskService.java                          # CREATE - Service class
│   ├── dto/
│   │   ├── request/
│   │   │   └── ChecklistItemDTO.java                 # CREATE - Request DTO
│   │   └── response/
│   │       └── TaskCompletionResponse.java           # CREATE - Response DTO
└── test/java/com/magnab/employeelifecycle/
    └── service/
        ├── TaskServiceTest.java                      # CREATE - Unit tests
        └── TaskServiceIntegrationTest.java           # CREATE - Integration tests
```

**Existing Files to Reference (DO NOT MODIFY unless needed):**
- Entity classes: TaskInstance, WorkflowInstance, TaskChecklistItem, ProvisionedItem, User (from previous stories)
- Repository interfaces: TaskInstanceRepository, WorkflowInstanceRepository, TaskChecklistItemRepository, ProvisionedItemRepository
- Service classes: WorkflowService (provides assignTasksForWorkflow() and checkAndCompleteWorkflow() methods)
- Enum classes: TaskStatus, WorkflowType, ItemCategory
- Exception classes: ResourceNotFoundException, ValidationException

### Business Logic - Offboarding Mirror
[Source: PRD Story 4.7, Story 4.1 Dev Notes]

**Critical Security Feature:**
The `completeTask` method implements the foundation for the "offboarding mirror" feature - a key differentiator of this system.

**How it Works:**
1. When a task is completed during ONBOARDING, all verified checklist items are persisted to `task_checklist_items` table
2. The same items are ALSO copied to `provisioned_items` table (AC #5)
3. During offboarding (Story 4.7), the system will query `provisioned_items` by employee and pre-populate offboarding task checklists
4. This ensures perfect symmetry: everything provisioned during onboarding is automatically deprovisioned during offboarding

**Why This Matters:**
- Current manual process results in forgotten accounts (MS 365, GitHub, SharePoint, Teams) and uncollected equipment
- Automated mirror ensures 100% coverage - eliminates orphaned accounts and security risks
- Category field enables smart routing (ACCESS items → account deprovisioning task, HARDWARE items → equipment collection task)

**Implementation Details:**
- Only create provisioned items if `workflow.getWorkflowType() == WorkflowType.ONBOARDING`
- For OFFBOARDING workflows, skip provisioned item creation (these workflows CONSUME provisioned items created during onboarding)
- Each ProvisionedItem must include: workflowInstanceId, taskInstanceId, itemDescription, category, itemIdentifier, provisionedAt, provisionedBy
- Log creation: `log.info("Created {} provisioned items for offboarding mirror", count);`

### Integration with WorkflowService
[Source: Story 3.3, Story 3.4]

**WorkflowService.assignTasksForWorkflow(UUID workflowId):**
- Purpose: Assigns tasks that are ready (dependencies satisfied, visible)
- Called from `completeTask` after task marked COMPLETED (AC #8)
- Automatically assigns dependent tasks when prerequisite task completes
- Example: If Task A depends on Task B, completing Task B triggers assignment of Task A

**WorkflowService.checkAndCompleteWorkflow(UUID workflowId, UUID userId):**
- Purpose: Checks if all visible tasks are COMPLETED, transitions workflow to COMPLETED if true
- Called from `completeTask` after task status updated (AC #7)
- Updates workflow status from IN_PROGRESS → COMPLETED
- Records state change in workflow_state_history table

**Why These Calls Matter:**
- Automatic workflow progression without manual intervention
- Dependent tasks get assigned immediately when prerequisites complete
- Workflow completes automatically when last task finishes
- All in single transaction with task completion (AC #9)

### Project Structure Alignment
[Source: docs/architecture/source-tree.md]

All file paths align with the defined source tree structure:
- Service in `backend/src/main/java/com/magnab/employeelifecycle/service/`
- Request DTOs in `backend/src/main/java/com/magnab/employeelifecycle/dto/request/`
- Response DTOs in `backend/src/main/java/com/magnab/employeelifecycle/dto/response/`
- Unit tests in `backend/src/test/java/com/magnab/employeelifecycle/service/`

No structural conflicts or deviations from architecture guidelines.

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**Unit Tests (JUnit 5 + Mockito):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/service/TaskServiceTest.java`
- Use `@ExtendWith(MockitoExtension.class)`
- Mock all repository and service dependencies with `@Mock`
- Inject TaskService with `@InjectMocks`
- Coverage goal: 80% for service layer

**Test Scenarios (AC #10 requires these tests):**
1. ✅ Successful task completion (all checklist items checked)
2. ✅ Validation failure (checklist item not checked)
3. ✅ Offboarding mirror creation (ONBOARDING workflow)
4. ✅ Offboarding mirror skipped (OFFBOARDING workflow)
5. ✅ Dependent task assignment triggered
6. ✅ Workflow completion check triggered
7. ✅ Task not found error
8. ✅ Invalid task status error (NOT_STARTED, COMPLETED)

**Integration Tests (TestContainers):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/service/TaskServiceIntegrationTest.java`
- Use `@SpringBootTest` and `@Testcontainers`
- Real PostgreSQL 17.2-alpine container
- Verify database state after task completion
- Test transaction rollback on validation failure

**Example Unit Test Structure:**
```java
@ExtendWith(MockitoExtension.class)
class TaskServiceTest {
    @Mock private TaskInstanceRepository taskInstanceRepository;
    @Mock private TaskChecklistItemRepository taskChecklistItemRepository;
    @Mock private ProvisionedItemRepository provisionedItemRepository;
    @Mock private WorkflowInstanceRepository workflowInstanceRepository;
    @Mock private WorkflowService workflowService;

    @InjectMocks
    private TaskService taskService;

    @Test
    void completeTask_ValidChecklistAllChecked_CompletesSuccessfully() {
        // Arrange: Mock task IN_PROGRESS, workflow ONBOARDING, checklist all checked
        UUID taskId = UUID.randomUUID();
        UUID userId = UUID.randomUUID();
        TaskInstance task = new TaskInstance();
        task.setId(taskId);
        task.setStatus(TaskStatus.IN_PROGRESS);
        task.setWorkflowInstanceId(UUID.randomUUID());

        WorkflowInstance workflow = new WorkflowInstance();
        workflow.setWorkflowType(WorkflowType.ONBOARDING);

        List<ChecklistItemDTO> checklistItems = List.of(
            new ChecklistItemDTO("Laptop Dell XPS", ItemCategory.HARDWARE, "SN123456", true),
            new ChecklistItemDTO("MS 365 License", ItemCategory.SOFTWARE, "LIC789", true)
        );

        when(taskInstanceRepository.findById(taskId)).thenReturn(Optional.of(task));
        when(workflowInstanceRepository.findById(task.getWorkflowInstanceId())).thenReturn(Optional.of(workflow));

        // Act
        TaskCompletionResponse response = taskService.completeTask(taskId, checklistItems, userId);

        // Assert
        verify(taskChecklistItemRepository).saveAll(argThat(items -> items.size() == 2));
        verify(provisionedItemRepository).saveAll(argThat(items -> items.size() == 2)); // Offboarding mirror
        verify(taskInstanceRepository).save(argThat(t -> t.getStatus() == TaskStatus.COMPLETED));
        verify(workflowService).checkAndCompleteWorkflow(workflow.getId(), userId);
        verify(workflowService).assignTasksForWorkflow(workflow.getId());

        assertEquals(TaskStatus.COMPLETED, response.getStatus());
        assertEquals(2, response.getChecklistItemsVerified());
        assertTrue(response.getOffboardingMirrorCreated());
    }

    @Test
    void completeTask_ChecklistItemNotChecked_ThrowsValidationException() {
        // Arrange: Checklist with 1 unchecked item
        UUID taskId = UUID.randomUUID();
        TaskInstance task = new TaskInstance();
        task.setStatus(TaskStatus.IN_PROGRESS);

        List<ChecklistItemDTO> checklistItems = List.of(
            new ChecklistItemDTO("Item 1", ItemCategory.HARDWARE, null, true),
            new ChecklistItemDTO("Item 2", ItemCategory.SOFTWARE, null, false) // NOT CHECKED!
        );

        when(taskInstanceRepository.findById(taskId)).thenReturn(Optional.of(task));

        // Act & Assert
        ValidationException ex = assertThrows(ValidationException.class, () -> {
            taskService.completeTask(taskId, checklistItems, userId);
        });

        assertEquals("All checklist items must be verified before completion", ex.getMessage());
        verify(taskChecklistItemRepository, never()).saveAll(any());
        verify(provisionedItemRepository, never()).saveAll(any());
    }
}
```

**Coverage Verification:**
- Run: `mvn test jacoco:report`
- Check: `backend/target/site/jacoco/index.html`
- Goal: 80% coverage for TaskService class

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-31 | 1.1 | Story validated and approved. Comprehensive validation completed: template compliance verified, all 10 ACs covered with 100% task mapping, anti-hallucination verification passed (30+ source references validated), implementation readiness confirmed (10/10 score). Complete service implementation with exact Java code provided. 9 unit tests + 2 integration tests specified. Zero critical issues found. Status updated from Draft to Approved. | Sarah (Product Owner) |
| 2025-10-31 | 1.0 | Story created from Epic 4 with complete service layer specification for task completion with mandatory checklist validation. Implements critical offboarding mirror feature by copying verified items to provisioned_items table. Includes transaction management, workflow progression triggers, comprehensive unit and integration testing requirements. Foundation for Task Completion API (Story 4.3) and Offboarding Mirror (Story 4.7). | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
