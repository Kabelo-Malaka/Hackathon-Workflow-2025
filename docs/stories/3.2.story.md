# Story 3.2: Workflow Instantiation Service

## Status
**Approved**

## Story

**As a** backend developer,
**I want** service logic that creates workflow instances from templates,
**so that** when HR initiates an onboarding/offboarding, all template tasks are copied to task instances with proper sequencing.

## Acceptance Criteria

1. WorkflowService.createWorkflowInstance(templateId, employeeDetails, customFieldValues, initiatedBy) method creates new workflow
2. Method copies all tasks from template to task_instances with references to template_task_id
3. Task sequence_order and dependency relationships are preserved from template
4. Custom field values provided by HR are stored in workflow_instance.custom_field_values as JSON
5. Conditional rules are evaluated immediately on creation; tasks that don't meet conditions are created but marked is_visible=false
6. Workflow status is set to INITIATED initially
7. All task statuses are set to NOT_STARTED initially
8. Audit record is created in workflow_state_history for workflow creation
9. Method returns workflow instance ID and summary (total tasks, immediate tasks to assign)
10. Transaction ensures all-or-nothing creation (workflow + all tasks + history record)
11. Unit tests cover various template scenarios (simple, parallel tasks, conditional tasks)

## Tasks / Subtasks

- [ ] **Task 1: Create WorkflowService class with createWorkflowInstance method** (AC: 1)
  - [ ] Create WorkflowService.java in service/ package
  - [ ] Add @Service annotation for Spring component scanning
  - [ ] Inject WorkflowInstanceRepository, TaskInstanceRepository, WorkflowStateHistoryRepository, WorkflowTemplateRepository, TemplateTaskRepository via constructor injection
  - [ ] Create createWorkflowInstance method with signature: WorkflowCreationResult createWorkflowInstance(UUID templateId, EmployeeDetails employeeDetails, Map<String, Object> customFieldValues, UUID initiatedBy)
  - [ ] Add @Transactional annotation to method for atomicity
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Transactional at service layer, constructor injection]

- [ ] **Task 2: Implement workflow instance creation logic** (AC: 1, 4, 6)
  - [ ] Validate that template exists and is active using WorkflowTemplateRepository
  - [ ] Create new WorkflowInstance entity with templateId, employeeName, employeeEmail, employeeRole from employeeDetails
  - [ ] Set workflowType from template.type
  - [ ] Set status to WorkflowStatus.INITIATED
  - [ ] Set initiatedBy and initiatedAt (LocalDateTime.now())
  - [ ] Store customFieldValues as JSONB in workflow_instance.custom_field_values
  - [ ] Save workflow instance using WorkflowInstanceRepository.save()
  - [ ] Reference: [Source: docs/architecture/data-models.md#WorkflowInstance]

- [ ] **Task 3: Copy all template tasks to task instances** (AC: 2, 3, 7)
  - [ ] Retrieve all template tasks using TemplateTaskRepository.findByTemplateId() ordered by sequence_order
  - [ ] For each template task, create new TaskInstance entity
  - [ ] Set workflowInstanceId, templateTaskId, taskName, assignedRole from template task
  - [ ] Preserve sequence_order and dependency relationships
  - [ ] Set status to TaskStatus.NOT_STARTED
  - [ ] Set isVisible to true by default (conditional evaluation in next task)
  - [ ] Batch save all task instances using TaskInstanceRepository.saveAll()
  - [ ] Reference: [Source: docs/architecture/data-models.md#TaskInstance, #TemplateTask]

- [ ] **Task 4: Evaluate conditional rules and set task visibility** (AC: 5)
  - [ ] For each created task instance, retrieve associated conditional rules from template
  - [ ] Evaluate each rule against customFieldValues using ConditionalRuleEvaluator (stub for MVP if not yet implemented)
  - [ ] If rule evaluation result is HIDE_TASK, set TaskInstance.isVisible = false
  - [ ] Update modified task instances
  - [ ] Reference: [Source: docs/architecture/data-models.md#TemplateConditionalRule]

- [ ] **Task 5: Create workflow state history audit record** (AC: 8)
  - [ ] Create new WorkflowStateHistory entity
  - [ ] Set workflowInstanceId to newly created workflow ID
  - [ ] Set previousStatus to null (or use a synthetic "NONE" value)
  - [ ] Set newStatus to WorkflowStatus.INITIATED
  - [ ] Set changedBy to initiatedBy
  - [ ] Set changedAt to LocalDateTime.now()
  - [ ] Set notes to "Workflow initiated"
  - [ ] Save using WorkflowStateHistoryRepository.save()
  - [ ] Reference: [Source: docs/architecture/data-models.md#WorkflowStateHistory]

- [ ] **Task 6: Calculate and return workflow creation summary** (AC: 9)
  - [ ] Count total tasks created (all task instances)
  - [ ] Count immediate tasks ready for assignment (visible tasks with no dependencies)
  - [ ] Create WorkflowCreationResult DTO with workflowInstanceId, totalTasks, immediateTasksCount
  - [ ] Return result from createWorkflowInstance method
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Always use DTOs at API boundaries]

- [ ] **Task 7: Create EmployeeDetails DTO** (AC: 1)
  - [ ] Create EmployeeDetails.java in dto/request/ package
  - [ ] Add fields: String employeeName, String employeeEmail, String employeeRole
  - [ ] Add Jakarta Bean Validation annotations (@NotNull, @Email, etc.)
  - [ ] Use Lombok @Data for getters/setters/constructors
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Naming: ActionEntityRequest pattern]

- [ ] **Task 8: Create WorkflowCreationResult DTO** (AC: 9)
  - [ ] Create WorkflowCreationResult.java in dto/response/ package
  - [ ] Add fields: UUID workflowInstanceId, Integer totalTasks, Integer immediateTasksCount
  - [ ] Use Lombok @Data
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - ActionEntityResponse pattern]

- [ ] **Task 9: Add comprehensive error handling** (AC: 1, 10)
  - [ ] Throw ResourceNotFoundException if template doesn't exist
  - [ ] Throw ValidationException if template is not active
  - [ ] Throw ValidationException if required custom fields are missing
  - [ ] Ensure @Transactional annotation provides rollback on any exception
  - [ ] Reference: [Source: docs/architecture/error-handling-strategy.md - Custom exceptions]

- [ ] **Task 10: Write unit tests for WorkflowService.createWorkflowInstance** (AC: 11)
  - [ ] Create WorkflowServiceTest.java in test/service/ package
  - [ ] Use @ExtendWith(MockitoExtension.class) and @InjectMocks/@Mock for dependencies
  - [ ] Test: createWorkflowInstance_WithValidTemplate_CreatesWorkflowAndTasks
  - [ ] Test: createWorkflowInstance_WithConditionalRules_HidesTasksBasedOnRules
  - [ ] Test: createWorkflowInstance_WithParallelTasks_PreservesTaskRelationships
  - [ ] Test: createWorkflowInstance_WithInvalidTemplate_ThrowsResourceNotFoundException
  - [ ] Test: createWorkflowInstance_WithInactiveTemplate_ThrowsValidationException
  - [ ] Test: createWorkflowInstance_CreatesStateHistoryRecord
  - [ ] Test: createWorkflowInstance_ReturnsCorrectTaskCounts
  - [ ] Verify @Transactional behavior (all entities saved or none)
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - Unit tests with JUnit 5 + Mockito, 80% coverage goal]

- [ ] **Task 11: Write integration test for WorkflowService** (AC: 10, 11)
  - [ ] Create WorkflowServiceIntegrationTest.java in test/service/ package
  - [ ] Use @SpringBootTest and @Testcontainers with PostgreSQL
  - [ ] Test full transaction with real database: workflow + tasks + history record created atomically
  - [ ] Verify rollback behavior if any step fails
  - [ ] Test with real template data from database (use seed data or create in test)
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - TestContainers integration tests]

## Dev Notes

### Previous Story Context
[Source: Story 3.1 Dev Agent Record]

Story 3.1 successfully completed the database schema foundation for Story 3.2:
- All database tables created: workflow_instances, task_instances, workflow_state_history
- All JPA entities created with Hibernate 6 native JSONB support (@JdbcTypeCode with SqlTypes.JSON)
- All repositories created with custom query methods
- 28 integration tests passing with TestContainers
- Key learning: Use Hibernate 6 native JSONB support instead of external libraries

**Entities available for Story 3.2:**
- WorkflowInstance, TaskInstance, WorkflowStateHistory (from Story 3.1)
- WorkflowTemplate, TemplateTask (from Story 2.1)
- User (from Story 1.x)

**Repositories available for Story 3.2:**
- WorkflowInstanceRepository, TaskInstanceRepository, WorkflowStateHistoryRepository (from Story 3.1)
- WorkflowTemplateRepository, TemplateTaskRepository (from Story 2.1)
- UserRepository (from Story 1.x)

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Backend Framework:**
- Spring Boot 3.2.2
- Java 17 LTS
- Hibernate 6.4.2 (via Spring Data JPA)
- Maven 3.9.6

**Testing:**
- JUnit 5 (5.10.1) for unit tests
- Mockito 5.8.0 for mocking
- TestContainers 1.19.3 for integration tests
- PostgreSQL 17.2 for test database

**Key Dependencies:**
- Lombok 1.18.30 (entities only, per coding standards)
- Jakarta Bean Validation 3.0.2 for DTO validation
- SLF4J + Logback for logging

### Data Models
[Source: docs/architecture/data-models.md]

**WorkflowInstance Entity:**
- Primary key: UUID id
- Foreign keys: templateId (WorkflowTemplate), initiatedBy (User)
- Status: Enum (INITIATED, IN_PROGRESS, BLOCKED, COMPLETED)
- Employee fields: employeeName, employeeEmail, employeeRole
- Custom data: customFieldValues (JSONB) - stores Map<String, Object>
- Audit: createdAt, updatedAt (auto-populated by @PrePersist/@PreUpdate)

**TaskInstance Entity:**
- Primary key: UUID id
- Foreign keys: workflowInstanceId (WorkflowInstance), templateTaskId (TemplateTask)
- Assignment: assignedUserId (User, nullable), assignedRole (Enum)
- Status: Enum (NOT_STARTED, IN_PROGRESS, BLOCKED, COMPLETED)
- Visibility: isVisible (Boolean) - controls conditional task display
- Due date: dueDate (LocalDateTime, nullable)
- Checklist: checklistData (JSONB) - stores partial completion data
- Audit: createdAt, updatedAt

**TemplateTask Entity:**
- Primary key: UUID id
- Foreign key: templateId (WorkflowTemplate)
- Metadata: taskName, description, assignedRole
- Sequencing: sequenceOrder (Integer), isParallel (Boolean)
- Dependencies: dependencyTaskId (self-referential FK to TemplateTask)

**WorkflowStateHistory Entity:**
- Primary key: UUID id
- Foreign keys: workflowInstanceId (WorkflowInstance), changedBy (User)
- State transition: previousStatus, newStatus (both WorkflowStatus enum)
- Timestamp: changedAt
- Context: notes (String, optional)

**TemplateConditionalRule Entity:**
- Primary key: UUID id
- Foreign key: taskId (TemplateTask)
- Rule: conditionField (String), conditionOperator (Enum: EQUALS, NOT_EQUALS, CONTAINS), conditionValue (String)
- Action: Enum (SHOW_TASK, HIDE_TASK)

**Relationships:**
- WorkflowInstance → TaskInstance (One-to-Many, cascade delete)
- WorkflowInstance → WorkflowStateHistory (One-to-Many, cascade delete)
- WorkflowTemplate → TemplateTask (One-to-Many)
- TemplateTask → TemplateTask (self-referential for dependencies)
- TemplateTask → TemplateConditionalRule (One-to-Many)

### Service Layer Patterns
[Source: docs/architecture/coding-standards.md]

**Critical Service Rules:**
1. **Constructor Injection:** All dependencies injected via constructor (immutable, final fields)
2. **@Transactional Annotation:** Place on service methods for transaction management
3. **DTO Usage:** Never expose entities directly, always use DTOs for request/response
4. **Specific Exceptions:** Throw ValidationException, ResourceNotFoundException, ConflictException (not generic RuntimeException)
5. **Return Optional:** For nullable results, use Optional<T>
6. **No @Async in Services:** Async only for email notifications (NotificationService), not workflow logic

**Naming Conventions:**
- Service class: EntityService (e.g., WorkflowService)
- Method pattern: verbEntity (e.g., createWorkflowInstance, assignTasksForWorkflow)
- DTOs: ActionEntityRequest/Response (e.g., EmployeeDetails as request, WorkflowCreationResult as response)

**Transaction Management:**
- Use @Transactional at service layer (not controller)
- Spring will auto-rollback on unchecked exceptions
- Multi-step operations (workflow + tasks + history) must be in single transaction

### Error Handling
[Source: docs/architecture/error-handling-strategy.md]

**Custom Exceptions to Use:**
- `ResourceNotFoundException` - Template not found (404)
- `ValidationException` - Template inactive or invalid custom fields (400)
- `ConflictException` - Business rule violations (409)

**Global Exception Handler:** Already implemented (GlobalExceptionHandler.java) - will catch custom exceptions and return standardized ErrorResponse

**Logging Standards:**
- Use SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(WorkflowService.class);`
- Log levels: ERROR (exceptions), WARN (degraded), INFO (workflow created), DEBUG (detailed flow)
- Never log sensitive data (passwords, tokens, PII)

### File Locations
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
```
backend/src/
├── main/java/com/magnab/employeelifecycle/
│   ├── service/
│   │   └── WorkflowService.java              # CREATE - Main service class
│   ├── dto/
│   │   ├── request/
│   │   │   └── EmployeeDetails.java          # CREATE - Request DTO
│   │   └── response/
│   │       └── WorkflowCreationResult.java   # CREATE - Response DTO
└── test/java/com/magnab/employeelifecycle/
    └── service/
        ├── WorkflowServiceTest.java          # CREATE - Unit tests
        └── WorkflowServiceIntegrationTest.java # CREATE - Integration tests
```

**Existing Files to Reference (DO NOT MODIFY):**
- Entity classes: WorkflowInstance, TaskInstance, WorkflowStateHistory, TemplateTask, WorkflowTemplate
- Repository interfaces: WorkflowInstanceRepository, TaskInstanceRepository, WorkflowStateHistoryRepository, TemplateTaskRepository, WorkflowTemplateRepository
- Exception classes: ResourceNotFoundException, ValidationException (in exception/ package)

### Conditional Logic Evaluation (Future Story)

For AC #5, conditional rule evaluation:
- Full ConditionalRuleEvaluator service will be implemented in a future story (Story 2.6 or similar)
- For MVP Story 3.2, stub the evaluation:
  - If no conditional rules exist for task, set isVisible = true
  - If conditional rules exist, evaluate simple EQUALS comparisons against customFieldValues map
  - For complex operators (CONTAINS, NOT_EQUALS), implement basic logic or defer to future story
- This allows Story 3.2 to be completed without blocking on full conditional logic

### JSONB Handling
[Source: Story 3.1 completion notes]

**Hibernate 6 Native JSONB:**
- Use `@JdbcTypeCode(SqlTypes.JSON)` annotation (already on entity fields)
- Pass Map<String, Object> directly - Hibernate serializes to JSON automatically
- No need for external libraries (hypersistence-utils not needed)

**Custom Field Values Example:**
```java
Map<String, Object> customFieldValues = Map.of(
    "start_date", "2025-11-15",
    "department", "Engineering",
    "remote_status", "hybrid"
);
workflowInstance.setCustomFieldValues(customFieldValues);
```

### Transaction Boundary

**All operations in createWorkflowInstance must be atomic:**
1. Create WorkflowInstance
2. Create all TaskInstance records (batch save)
3. Evaluate conditional rules and update task visibility
4. Create WorkflowStateHistory record

If any step fails, entire transaction rolls back. This is enforced by @Transactional annotation on service method.

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**Unit Tests (JUnit 5 + Mockito):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/service/WorkflowServiceTest.java`
- Use @ExtendWith(MockitoExtension.class)
- Mock all repository dependencies with @Mock
- Inject WorkflowService with @InjectMocks
- Coverage goal: 80% for service layer

**Test Scenarios:**
1. Happy path: Valid template creates workflow + tasks + history
2. Conditional rules: Tasks marked invisible based on custom field values
3. Parallel tasks: Multiple tasks with same sequence_order handled correctly
4. Error cases: Template not found, template inactive, missing custom fields
5. Transaction rollback: Verify all-or-nothing behavior

**Integration Tests (TestContainers):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/service/WorkflowServiceIntegrationTest.java`
- Use @SpringBootTest and @Testcontainers
- Real PostgreSQL 17-alpine container
- Verify database state after workflow creation
- Test transaction rollback with real database

**Example Unit Test Structure:**
```java
@ExtendWith(MockitoExtension.class)
class WorkflowServiceTest {
    @Mock private WorkflowInstanceRepository workflowInstanceRepo;
    @Mock private TaskInstanceRepository taskInstanceRepo;
    @Mock private WorkflowStateHistoryRepository historyRepo;
    @Mock private WorkflowTemplateRepository templateRepo;
    @Mock private TemplateTaskRepository templateTaskRepo;

    @InjectMocks
    private WorkflowService workflowService;

    @Test
    void createWorkflowInstance_WithValidTemplate_CreatesWorkflowAndTasks() {
        // Arrange: Mock template, template tasks
        // Act: Call workflowService.createWorkflowInstance()
        // Assert: Verify repository save calls, result DTO
    }
}
```

**Manual Testing:**
- After Story 3.2 completes, Story 3.5 will create API endpoint
- Use Postman to test POST /api/workflows with real payloads
- Verify database records created correctly

**Coverage Verification:**
- Run: `mvn test jacoco:report`
- Check: `target/site/jacoco/index.html`
- Goal: 80% coverage for WorkflowService class

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-31 | 1.0 | Story created from Epic 3 with complete service layer specification for workflow instantiation. Includes transaction management, conditional rule evaluation, comprehensive unit and integration testing requirements. Builds on Story 3.1 database foundation. | Bob (Scrum Master) |
| 2025-10-31 | 1.1 | Story validated and approved for implementation. Validation Score: 9.96/10 (Outstanding). Zero critical issues, zero hallucinations detected, 100% AC coverage, complete implementation readiness. PO Assessment: Textbook example of excellent story preparation - ready for immediate development. | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
