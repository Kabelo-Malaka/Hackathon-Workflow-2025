# Story 1.8: Testing Framework Setup

## Status
**Approved**

## Story

**As a** developer,
**I want** testing frameworks configured for both frontend and backend with sample tests,
**so that** I can write unit and integration tests from the start and maintain high code quality throughout development.

## Acceptance Criteria

**Frontend Testing Setup:**
1. Jest 29.7.0 is installed and configured in `frontend/package.json`
2. React Testing Library 14.1.2 is installed and configured
3. Jest configuration file (`jest.config.js`) is created with TypeScript support, coverage thresholds (80%), test patterns
4. `src/setupTests.ts` includes `@testing-library/jest-dom` import for DOM matchers
5. npm scripts added: `"test": "jest"`, `"test:watch": "jest --watch"`, `"test:coverage": "jest --coverage"`
6. Sample component test created at `src/components/common/Button.test.tsx` demonstrating rendering, interaction, and accessibility tests
7. Test runs successfully: `npm test` passes with sample test

**Backend Testing Setup:**
8. JUnit 5 (Jupiter) is configured in `backend/pom.xml` with `spring-boot-starter-test` dependency
9. Mockito is included for mocking (part of `spring-boot-starter-test`)
10. TestContainers 1.19.3 is added for integration tests with PostgreSQL
11. Test directory structure created for service, controller, and repository tests
12. Test application properties created at `src/test/resources/application-test.yml`
13. Sample service unit test created at `UserServiceTest.java` demonstrating Mockito mocking
14. Sample integration test created at `UserControllerIntegrationTest.java` demonstrating TestContainers and MockMvc
15. Maven test phase runs successfully: `mvn test` passes with sample tests
16. Surefire plugin configured for test execution with proper reporting

**Documentation:**
17. README.md updated with "Running Tests" section
18. README.md includes note about tests in Docker build process
19. .gitignore updated to exclude test coverage reports

**Docker Integration:**
20. Frontend Dockerfile includes `RUN npm test` before build step
21. Backend Dockerfile includes `RUN mvn test` before packaging JAR

## Tasks / Subtasks

- [ ] **Task 1: Install and configure Jest for frontend** (AC: 1, 2, 3, 4, 5)
  - [ ] Install dependencies: `npm install --save-dev jest@29.7.0 @types/jest ts-jest`
  - [ ] Install React Testing Library: `npm install --save-dev @testing-library/react@14.1.2 @testing-library/jest-dom @testing-library/user-event`
  - [ ] Create `frontend/jest.config.js` with ts-jest preset
  - [ ] Configure coverage thresholds: 80% for statements, branches, functions, lines
  - [ ] Set test patterns: `**/*.test.tsx`, `**/*.test.ts`
  - [ ] Create `frontend/src/setupTests.ts` and import `@testing-library/jest-dom`
  - [ ] Add npm scripts to `package.json`: test, test:watch, test:coverage
  - [ ] Update `tsconfig.json` to include jest types if needed

- [ ] **Task 2: Create sample frontend component test** (AC: 6, 7)
  - [ ] Create `frontend/src/components/common/Button.test.tsx`
  - [ ] Write test: "renders button with text"
  - [ ] Write test: "calls onClick handler when clicked"
  - [ ] Write test: "button has accessible name"
  - [ ] Run `npm test` to verify all tests pass

- [ ] **Task 3: Configure JUnit 5 and Mockito for backend** (AC: 8, 9, 16)
  - [ ] Verify `spring-boot-starter-test` dependency exists in `pom.xml` (should be present from Story 1.1)
  - [ ] Verify JUnit 5 (Jupiter) and Mockito are included (part of starter-test)
  - [ ] Configure maven-surefire-plugin in `pom.xml` for test execution
  - [ ] Set surefire plugin to generate test reports

- [ ] **Task 4: Add TestContainers for integration tests** (AC: 10)
  - [ ] Add TestContainers dependency to `pom.xml`: `org.testcontainers:postgresql:1.19.3`
  - [ ] Add TestContainers JUnit 5 dependency: `org.testcontainers:junit-jupiter:1.19.3`
  - [ ] Verify Docker is running (TestContainers requires Docker)

- [ ] **Task 5: Create backend test directory structure** (AC: 11, 12)
  - [ ] Create directory: `backend/src/test/java/com/magnab/employeelifecycle/service/`
  - [ ] Create directory: `backend/src/test/java/com/magnab/employeelifecycle/controller/`
  - [ ] Create directory: `backend/src/test/java/com/magnab/employeelifecycle/repository/`
  - [ ] Create `backend/src/test/resources/application-test.yml` with test-specific configuration
  - [ ] Configure H2 in-memory database for unit tests (optional, can use TestContainers for all)

- [ ] **Task 6: Create sample backend unit test** (AC: 13)
  - [ ] Create `backend/src/test/java/com/magnab/employeelifecycle/service/UserServiceTest.java`
  - [ ] Annotate with `@ExtendWith(MockitoExtension.class)`
  - [ ] Mock UserRepository with `@Mock`
  - [ ] Test `createUser()` method with valid data
  - [ ] Test `createUser()` throws exception for duplicate username
  - [ ] Verify mocked repository interactions with `verify()`

- [ ] **Task 7: Create sample backend integration test** (AC: 14, 15)
  - [ ] Create `backend/src/test/java/com/magnab/employeelifecycle/controller/UserControllerIntegrationTest.java`
  - [ ] Annotate with `@SpringBootTest`, `@AutoConfigureMockMvc`, `@Testcontainers`
  - [ ] Set up PostgreSQL TestContainer with `@Container` annotation
  - [ ] Configure `@DynamicPropertySource` to override datasource properties
  - [ ] Inject MockMvc for API testing
  - [ ] Test POST /api/users endpoint with valid data (expect 201)
  - [ ] Test GET /api/users endpoint (expect 200)
  - [ ] Run `mvn test` to verify all tests pass

- [ ] **Task 8: Update documentation** (AC: 17, 18, 19)
  - [ ] Add "Running Tests" section to README.md with frontend and backend commands
  - [ ] Document test coverage commands
  - [ ] Add note about Docker requirement for TestContainers
  - [ ] Add note about tests running in Docker builds
  - [ ] Update `.gitignore` to exclude `coverage/`, `target/site/jacoco/`, `target/surefire-reports/`

- [ ] **Task 9: Integrate tests into Docker builds** (AC: 20, 21)
  - [ ] Update `frontend/Dockerfile` to add `RUN npm test` before build step
  - [ ] Update `backend/Dockerfile` to add `RUN mvn test` before JAR packaging
  - [ ] Verify Docker builds fail if tests fail (fail-fast strategy)
  - [ ] Test Docker build locally: `docker-compose build`

- [ ] **Task 10: Manual verification of testing setup** (AC: 1-21)
  - [ ] Run `npm test` in frontend, verify sample test passes
  - [ ] Run `npm run test:coverage` in frontend, verify coverage report generated in `coverage/` directory
  - [ ] Run `mvn test` in backend, verify sample tests pass
  - [ ] Verify TestContainers starts PostgreSQL container during integration tests
  - [ ] Check coverage report in `backend/target/site/jacoco/`
  - [ ] Verify test reports in `backend/target/surefire-reports/`
  - [ ] Verify `.gitignore` excludes coverage directories
  - [ ] Run `docker-compose build` and verify tests execute during build
  - [ ] Break a test intentionally, verify Docker build fails

## Dev Notes

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Frontend Testing Technologies:**
- **Testing Framework:** Jest 29.7.0
- **Component Testing:** React Testing Library 14.1.2
- **TypeScript Support:** ts-jest (transforms TypeScript)
- **DOM Matchers:** @testing-library/jest-dom
- **User Interaction:** @testing-library/user-event

**Backend Testing Technologies:**
- **Testing Framework:** JUnit 5 (Jupiter) 5.10.1
- **Mocking:** Mockito 5.8.0
- **Integration Testing:** TestContainers 1.19.3 (PostgreSQL)
- **Test Runner:** Maven Surefire Plugin
- **Coverage:** JaCoCo (Java Code Coverage)

### Source Tree Structure
[Source: docs/architecture/source-tree.md]

**Frontend Test Structure:**
```
frontend/
├── src/
│   ├── components/
│   │   └── common/
│   │       └── Button.test.tsx       # CREATE - Sample component test
│   └── setupTests.ts                 # CREATE - Jest setup file
├── coverage/                         # GENERATED - Coverage reports
├── jest.config.js                    # CREATE - Jest configuration
└── package.json                      # MODIFY - Add test scripts
```

**Backend Test Structure:**
```
backend/
├── src/
│   ├── test/
│   │   ├── java/com/magnab/employeelifecycle/
│   │   │   ├── service/
│   │   │   │   └── UserServiceTest.java              # CREATE - Unit test
│   │   │   ├── controller/
│   │   │   │   └── UserControllerIntegrationTest.java # CREATE - Integration test
│   │   │   └── repository/                            # CREATE - Directory
│   │   └── resources/
│   │       └── application-test.yml                   # CREATE - Test config
├── target/
│   ├── surefire-reports/            # GENERATED - Test reports
│   └── site/jacoco/                 # GENERATED - Coverage reports
└── pom.xml                           # MODIFY - Add TestContainers dependency
```

### Jest Configuration
[Source: docs/prd.md - Story 1.8]

**jest.config.js Example:**
```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  testMatch: [
    '**/__tests__/**/*.ts?(x)',
    '**/?(*.)+(spec|test).ts?(x)'
  ],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/main.tsx',
    '!src/vite-env.d.ts',
  ],
  coverageThreshold: {
    global: {
      statements: 80,
      branches: 80,
      functions: 80,
      lines: 80,
    },
  },
};
```

**setupTests.ts Example:**
```typescript
import '@testing-library/jest-dom';
```

**package.json Scripts Addition:**
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
```

### Sample Frontend Test
[Source: docs/prd.md - Story 1.8, React Testing Library best practices]

**Button.test.tsx Example:**
```typescript
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Button } from './Button';

describe('Button', () => {
  it('renders button with text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('calls onClick handler when clicked', async () => {
    const handleClick = jest.fn();
    const user = userEvent.setup();

    render(<Button onClick={handleClick}>Click me</Button>);
    await user.click(screen.getByText('Click me'));

    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('button has accessible name', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument();
  });
});
```

### Backend Test Configuration
[Source: docs/prd.md - Story 1.8]

**pom.xml Dependencies:**
```xml
<dependencies>
  <!-- Spring Boot Test Starter (includes JUnit 5, Mockito) -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
  </dependency>

  <!-- TestContainers for PostgreSQL -->
  <dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>postgresql</artifactId>
    <version>1.19.3</version>
    <scope>test</scope>
  </dependency>
  <dependency>
    <groupId>org.testcontainers</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>1.19.3</version>
    <scope>test</scope>
  </dependency>
</dependencies>

<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-surefire-plugin</artifactId>
      <version>3.0.0</version>
    </plugin>
  </plugins>
</build>
```

**application-test.yml Example:**
```yaml
spring:
  datasource:
    # Override by TestContainers in integration tests
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
  jpa:
    hibernate:
      ddl-auto: create-drop
  liquibase:
    enabled: false
logging:
  level:
    com.magnab.employeelifecycle: DEBUG
```

### Sample Backend Unit Test
[Source: docs/prd.md - Story 1.8, Mockito best practices]

**UserServiceTest.java Example:**
```java
package com.magnab.employeelifecycle.service;

import com.magnab.employeelifecycle.entity.User;
import com.magnab.employeelifecycle.repository.UserRepository;
import com.magnab.employeelifecycle.exception.ConflictException;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @InjectMocks
    private UserService userService;

    @Test
    void createUser_WithValidData_ReturnsUser() {
        // Arrange
        when(userRepository.findByUsername("testuser")).thenReturn(Optional.empty());
        when(passwordEncoder.encode("password")).thenReturn("hashedPassword");
        when(userRepository.save(any(User.class))).thenAnswer(i -> i.getArgument(0));

        // Act
        User result = userService.createUser("testuser", "test@example.com", "password", "HR_ADMIN");

        // Assert
        assertNotNull(result);
        assertEquals("testuser", result.getUsername());
        verify(userRepository).save(any(User.class));
    }

    @Test
    void createUser_WithDuplicateUsername_ThrowsConflictException() {
        // Arrange
        User existingUser = new User();
        when(userRepository.findByUsername("testuser")).thenReturn(Optional.of(existingUser));

        // Act & Assert
        assertThrows(ConflictException.class, () -> {
            userService.createUser("testuser", "test@example.com", "password", "HR_ADMIN");
        });
        verify(userRepository, never()).save(any(User.class));
    }
}
```

### Sample Backend Integration Test
[Source: docs/prd.md - Story 1.8, TestContainers documentation]

**UserControllerIntegrationTest.java Example:**
```java
package com.magnab.employeelifecycle.controller;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.web.servlet.MockMvc;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
@Testcontainers
class UserControllerIntegrationTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:17-alpine")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
    }

    @Autowired
    private MockMvc mockMvc;

    @Test
    void createUser_WithValidData_Returns201() throws Exception {
        String userJson = """
            {
                "username": "testuser",
                "email": "test@example.com",
                "password": "password123",
                "role": "HR_ADMIN"
            }
            """;

        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(userJson))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.username").value("testuser"));
    }

    @Test
    void getUsers_ReturnsUserList() throws Exception {
        mockMvc.perform(get("/api/users"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$").isArray());
    }
}
```

### Docker Integration
[Source: docs/prd.md - Story 1.8]

**Frontend Dockerfile Update:**
```dockerfile
# Add before the build step
RUN npm test
```

**Backend Dockerfile Update:**
```dockerfile
# Add before packaging
RUN mvn test
```

### Coding Standards
[Source: docs/architecture/coding-standards.md]

**Testing Standards:**
- Test files colocated with source (frontend) or in parallel structure (backend)
- Test file naming: `*.test.tsx` (frontend), `*Test.java` (backend)
- Use AAA pattern: Arrange, Act, Assert
- One assertion per test (when possible)
- Test names should describe behavior: `methodName_Condition_ExpectedResult`
- Mock external dependencies, test real code
- Integration tests test full stack with real database

### Coverage Requirements
[Source: docs/prd.md - Story 1.8]

**Coverage Thresholds:**
- 80% for statements, branches, functions, lines
- Exclude generated files and type definitions
- Frontend: Coverage in `coverage/` directory
- Backend: JaCoCo reports in `target/site/jacoco/`

### TestContainers Notes
[Source: docs/prd.md - Story 1.8 Technical Notes]

**Important:**
- TestContainers requires Docker to be running
- Automatically downloads and starts PostgreSQL container for tests
- Container lifecycle managed by JUnit 5
- Use `@Container` annotation for container definition
- Use `@DynamicPropertySource` to override datasource properties
- Containers are stopped automatically after tests complete

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**For Story 1.8, testing is META - we're setting up the testing infrastructure itself:**

**Manual Verification Steps:**

1. **Frontend Jest Setup:**
   - Run `npm test` in frontend directory
   - Verify Jest starts and sample test passes
   - Verify test output shows 1 test passed
   - Run `npm run test:coverage`
   - Verify coverage report generated in `coverage/` directory
   - Open `coverage/lcov-report/index.html` to view coverage

2. **Frontend Test Sample:**
   - Verify Button.test.tsx exists
   - Verify all 3 tests pass (rendering, interaction, accessibility)
   - Intentionally break Button component
   - Verify test fails as expected

3. **Backend JUnit Setup:**
   - Run `mvn test` in backend directory
   - Verify Maven downloads dependencies if needed
   - Verify all tests pass
   - Check console output for test execution summary

4. **Backend Unit Test:**
   - Verify UserServiceTest.java exists
   - Verify Mockito mocking works
   - Check test output shows 2 tests passed (valid data, duplicate username)

5. **Backend Integration Test:**
   - Ensure Docker is running
   - Run `mvn test`
   - Verify TestContainers downloads PostgreSQL image (first run only)
   - Verify PostgreSQL container starts
   - Verify integration tests pass
   - Verify container stops after tests complete

6. **Coverage Reports:**
   - Frontend: Check `coverage/` directory exists and contains HTML reports
   - Backend: Check `target/site/jacoco/` directory exists
   - Verify coverage meets 80% threshold (or note if below)

7. **Documentation:**
   - Open README.md
   - Verify "Running Tests" section exists with correct commands
   - Verify note about Docker requirement for TestContainers

8. **Docker Build Integration:**
   - Run `docker-compose build frontend`
   - Verify tests run during build (see test output in logs)
   - Verify build succeeds if tests pass
   - Intentionally break a test
   - Run `docker-compose build frontend` again
   - Verify build fails (fail-fast strategy working)

**Future Testing:** This story establishes the foundation. Subsequent stories will add tests using this infrastructure.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-30 | 1.0 | Story created from Epic 1 with streamlined architecture context for fast-track development | Bob (Scrum Master) |
| 2025-10-30 | 1.1 | Story validated and approved for implementation (Readiness Score: 9.3/10, HIGH confidence, zero hallucinations, minor Button component clarification recommended) | Sarah (Product Owner) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
