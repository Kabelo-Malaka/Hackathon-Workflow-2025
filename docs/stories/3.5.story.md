# Story 3.5: Workflow Initiation API

## Status
**Approved**

## Story

**As an** HR Administrator,
**I want** API endpoint to initiate new onboarding/offboarding workflows,
**so that** I can start employee transitions through the system.

## Acceptance Criteria

1. API endpoint POST /api/workflows accepts: template_id, employee_name, employee_email, employee_role, custom_field_values (JSON object)
2. Only HR_ADMIN role can initiate workflows (403 Forbidden for others)
3. Endpoint validates that template exists and is active
4. Endpoint validates that required custom fields are provided
5. Endpoint calls WorkflowService.createWorkflowInstance() to create workflow
6. Endpoint calls WorkflowService.assignTasksForWorkflow() to assign initial tasks
7. Endpoint returns 201 Created with workflow instance ID and summary (tasks created, tasks assigned)
8. Failed validation returns 400 Bad Request with detailed error messages
9. Endpoint is transactional (all-or-nothing workflow creation)
10. Swagger documentation includes example request/response

## Tasks / Subtasks

- [ ] **Task 1: Create InitiateWorkflowRequest DTO** (AC: 1)
  - [ ] Create InitiateWorkflowRequest.java in dto/request/ package
  - [ ] Add fields: UUID templateId, String employeeName, String employeeEmail, String employeeRole, Map<String, Object> customFieldValues
  - [ ] Add Jakarta Bean Validation annotations: @NotNull on templateId, @NotBlank on employeeName/employeeEmail/employeeRole, @Email on employeeEmail
  - [ ] Use @Valid annotation for nested validation if needed
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Jakarta Bean Validation at API boundary]

- [ ] **Task 2: Create WorkflowInitiationResponse DTO** (AC: 7)
  - [ ] Create WorkflowInitiationResponse.java in dto/response/ package
  - [ ] Add fields: UUID workflowInstanceId, String employeeName, WorkflowStatus status, Integer totalTasksCreated, Integer tasksAssigned, LocalDateTime initiatedAt
  - [ ] Use Lombok @Data annotation for getters/setters
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - ActionEntityResponse pattern]

- [ ] **Task 3: Create WorkflowController class** (AC: 1, 2)
  - [ ] Create WorkflowController.java in controller/ package
  - [ ] Add @RestController and @RequestMapping("/api/workflows") annotations
  - [ ] Inject WorkflowService via constructor injection (final field)
  - [ ] Add SLF4J logger: private static final Logger log = LoggerFactory.getLogger(WorkflowController.class);
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Constructor injection pattern]

- [ ] **Task 4: Implement POST /api/workflows endpoint** (AC: 1, 2, 5, 6, 7)
  - [ ] Create method: `ResponseEntity<WorkflowInitiationResponse> initiateWorkflow(@Valid @RequestBody InitiateWorkflowRequest request)`
  - [ ] Add @PostMapping annotation (no additional path, endpoint is /api/workflows)
  - [ ] Add @PreAuthorize("hasRole('HR_ADMIN')") annotation for authorization
  - [ ] Add @Valid annotation on request parameter for validation
  - [ ] Call WorkflowService.createWorkflowInstance(request.getTemplateId(), employeeDetails, request.getCustomFieldValues(), getCurrentUserId())
  - [ ] Extract workflowInstanceId from WorkflowCreationResult
  - [ ] Call WorkflowService.assignTasksForWorkflow(workflowInstanceId)
  - [ ] Build WorkflowInitiationResponse with workflow ID, employee name, status, task counts, timestamp
  - [ ] Return ResponseEntity.status(HttpStatus.CREATED).body(response)
  - [ ] Log workflow initiation: log.info("Workflow initiated for employee: {} by user: {}", employeeName, userId)
  - [ ] Reference: [Source: docs/architecture/security.md - @PreAuthorize pattern]

- [ ] **Task 5: Implement getCurrentUserId() helper method** (AC: 5)
  - [ ] Create private helper method: `UUID getCurrentUserId()`
  - [ ] Use SecurityContextHolder.getContext().getAuthentication() to get current user
  - [ ] Extract User object from authentication principal
  - [ ] Return user.getId()
  - [ ] Throw UnauthorizedException if no authenticated user found
  - [ ] Reference: [Source: docs/architecture/security.md - Session-based authentication]

- [ ] **Task 6: Add validation for template exists and is active** (AC: 3)
  - [ ] Validation handled by WorkflowService.createWorkflowInstance() method (from Story 3.2)
  - [ ] If template not found or inactive, service throws ValidationException
  - [ ] Controller lets exception propagate to GlobalExceptionHandler
  - [ ] GlobalExceptionHandler returns 400 Bad Request with error details
  - [ ] Reference: [Source: Story 3.2 - createWorkflowInstance validates template]

- [ ] **Task 7: Add validation for required custom fields** (AC: 4)
  - [ ] Validation handled by WorkflowService.createWorkflowInstance() method (from Story 3.2)
  - [ ] Service validates required fields are present in customFieldValues
  - [ ] If required field missing, service throws ValidationException with field name
  - [ ] GlobalExceptionHandler returns 400 Bad Request with specific error message
  - [ ] Reference: [Source: Story 3.2 - createWorkflowInstance validates custom fields]

- [ ] **Task 8: Ensure transactional behavior** (AC: 9)
  - [ ] WorkflowService.createWorkflowInstance() and assignTasksForWorkflow() are both @Transactional
  - [ ] Controller method does NOT need @Transactional (transaction at service layer)
  - [ ] If assignTasksForWorkflow() fails, createWorkflowInstance() transaction will rollback
  - [ ] Spring manages transaction propagation automatically
  - [ ] Reference: [Source: docs/architecture/coding-standards.md - Transactional at service layer, not controller]

- [ ] **Task 9: Add OpenAPI/Swagger documentation** (AC: 10)
  - [ ] Add @Operation annotation with summary: "Initiate new onboarding or offboarding workflow"
  - [ ] Add @ApiResponses with 201 Created, 400 Bad Request, 403 Forbidden, 404 Not Found responses
  - [ ] Add @Schema annotations on DTO fields with descriptions and examples
  - [ ] Add @io.swagger.v3.oas.annotations.parameters.RequestBody with example JSON
  - [ ] Example request: {"templateId": "uuid", "employeeName": "John Doe", "employeeEmail": "john.doe@company.com", "employeeRole": "Software Engineer", "customFieldValues": {"startDate": "2025-02-01", "remoteStatus": "hybrid"}}
  - [ ] Example response: {"workflowInstanceId": "uuid", "employeeName": "John Doe", "status": "IN_PROGRESS", "totalTasksCreated": 15, "tasksAssigned": 3, "initiatedAt": "2025-10-31T10:30:00"}
  - [ ] Reference: [Source: docs/architecture/tech-stack.md - SpringDoc OpenAPI 2.3.0]

- [ ] **Task 10: Write unit tests for WorkflowController** (AC: 1-10)
  - [ ] Create WorkflowControllerTest.java in test/controller/ package
  - [ ] Use @ExtendWith(MockitoExtension.class)
  - [ ] Mock WorkflowService with @Mock
  - [ ] Use @InjectMocks for WorkflowController
  - [ ] Test: initiateWorkflow_ValidRequest_Returns201Created
  - [ ] Test: initiateWorkflow_AsNonHRAdmin_Returns403Forbidden (use @WithMockUser(roles = "LINE_MANAGER"))
  - [ ] Test: initiateWorkflow_InvalidRequest_Returns400BadRequest (missing required fields)
  - [ ] Test: initiateWorkflow_TemplateNotFound_Returns404NotFound
  - [ ] Test: initiateWorkflow_ServiceThrowsValidationException_Returns400BadRequest
  - [ ] Verify service methods called with correct parameters
  - [ ] Verify response DTO populated correctly
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - Unit tests with JUnit 5 + Mockito]

- [ ] **Task 11: Write integration test for WorkflowController** (AC: 1-10)
  - [ ] Create WorkflowControllerIntegrationTest.java in test/controller/ package
  - [ ] Use @SpringBootTest and @Testcontainers
  - [ ] Use PostgreSQL container: new PostgreSQLContainer<>("postgres:17.2-alpine")
  - [ ] Use @Autowired WebTestClient or MockMvc for HTTP requests
  - [ ] Set up test data: Create active workflow template, user with HR_ADMIN role
  - [ ] Test: POST /api/workflows with valid request returns 201 and creates workflow in database
  - [ ] Test: POST /api/workflows as non-HR_ADMIN returns 403
  - [ ] Test: POST /api/workflows with invalid template ID returns 404
  - [ ] Test: POST /api/workflows with missing required custom field returns 400
  - [ ] Verify workflow_instances and task_instances tables populated correctly
  - [ ] Verify workflow_state_history record created
  - [ ] Reference: [Source: docs/architecture/test-strategy.md - TestContainers integration tests]

## Dev Notes

### Previous Story Context

**Story 3.2: Workflow Instantiation Service (Done)**

Story 3.2 implemented the core service method that Story 3.5 will call:
- `WorkflowService.createWorkflowInstance(UUID templateId, EmployeeDetails employeeDetails, Map<String, Object> customFieldValues, UUID initiatedBy)` creates new workflow
- Returns `WorkflowCreationResult` DTO with fields: UUID workflowInstanceId, Integer totalTasksCreated, Integer visibleTasksCreated
- Method is @Transactional and validates template exists/active and required custom fields provided
- Throws ResourceNotFoundException if template not found, ValidationException if validation fails

**Story 3.3: Task Assignment & Routing Logic (Approved)**

Story 3.3 implemented the task assignment method that Story 3.5 will call:
- `WorkflowService.assignTasksForWorkflow(UUID workflowInstanceId)` assigns ready tasks to users
- Returns `List<TaskAssignmentResult>` with fields: UUID taskInstanceId, UUID assignedUserId, String assignedUserEmail, String taskName, LocalDateTime dueDate
- Method is @Transactional and idempotent (can be called multiple times safely)
- Automatically transitions workflow status from INITIATED to IN_PROGRESS when first task assigned

**Integration Pattern:**
Story 3.5 acts as the API gateway that orchestrates these two service methods in sequence:
1. Call createWorkflowInstance() to create workflow and tasks
2. Call assignTasksForWorkflow() to assign ready tasks
3. Combine results into single response DTO for frontend

### Technology Stack
[Source: docs/architecture/tech-stack.md]

**Backend Framework:**
- Spring Boot 3.2.2
- Java 17 LTS
- Spring MVC for REST controllers
- Maven 3.9.6

**Security:**
- Spring Security 6.2.1
- Session-based authentication (JSESSIONID cookie, 15-minute timeout)
- BCrypt password hashing

**API Documentation:**
- SpringDoc OpenAPI 2.3.0
- Swagger UI auto-generated at /swagger-ui.html

**Validation:**
- Jakarta Bean Validation 3.0.2
- Declarative validation with @Valid, @NotNull, @NotBlank, @Email annotations

**Testing:**
- JUnit 5 (5.10.1) for unit tests
- Mockito 5.8.0 for mocking
- TestContainers 1.19.3 for integration tests
- PostgreSQL 17.2 for test database

### REST API Patterns
[Source: docs/architecture/rest-api-spec.md]

**Base URL:** http://localhost:8080/api

**Authentication:** Session-based (JSESSIONID cookie, 15-minute timeout)

**Endpoint Groups:**
- `/api/workflows/*` - Workflow instance operations (this story creates POST /api/workflows)

**Key Design Decisions:**
1. Session-based auth (no JWT for MVP simplicity)
2. Role-based access control enforced at endpoint level with @PreAuthorize
3. Consistent error response format (timestamp, status, error, message, path)
4. DTO pattern (never expose entities, separate request/response DTOs)
5. Validation at API boundary before service layer

**Error Response Format:**
```json
{
  "timestamp": "2025-10-31T10:30:00",
  "status": 400,
  "error": "Bad Request",
  "message": "Validation failed: employeeName must not be blank",
  "path": "/api/workflows"
}
```

### Security & Authorization
[Source: docs/architecture/security.md]

**Authorization Pattern:**
```java
@PreAuthorize("hasRole('HR_ADMIN')")
@PostMapping("/api/workflows")
public ResponseEntity<WorkflowInitiationResponse> initiateWorkflow(...) {
    // Only HR_ADMIN can initiate workflows
}
```

**Role Enum Values:**
- HR_ADMIN - Can initiate workflows
- LINE_MANAGER - Cannot initiate workflows
- TECH_SUPPORT - Cannot initiate workflows
- ADMINISTRATOR - Cannot initiate workflows (admin role is for user management, not workflow operations)

**Input Validation:**
- Jakarta Bean Validation (@Valid on request DTOs)
- Whitelist approach (define allowed values)
- Validation at API boundary before service layer

**CSRF Protection:** Enabled for all non-GET requests (Spring Security default)

**Getting Current User:**
```java
private UUID getCurrentUserId() {
    Authentication auth = SecurityContextHolder.getContext().getAuthentication();
    User user = (User) auth.getPrincipal();
    return user.getId();
}
```

### Controller Layer Patterns
[Source: docs/architecture/coding-standards.md]

**Critical Controller Rules:**
1. **Constructor Injection:** All dependencies injected via constructor (immutable, final fields)
2. **@RestController + @RequestMapping:** Use both annotations at class level
3. **No @Transactional:** Transaction management belongs at service layer, NOT controller
4. **@Valid on Request Body:** Enable automatic validation
5. **@PreAuthorize for RBAC:** Secure endpoints with role checks
6. **Return ResponseEntity:** Use ResponseEntity<T> for explicit HTTP status codes
7. **Logger:** Use SLF4J logger: `private static final Logger log = LoggerFactory.getLogger(WorkflowController.class);`

**Naming Conventions:**
- Controller class: EntityController (e.g., WorkflowController)
- Method names: verbNoun (e.g., initiateWorkflow, not createWorkflow)
- DTOs: ActionEntityRequest/Response (e.g., InitiateWorkflowRequest, WorkflowInitiationResponse)

**HTTP Status Codes:**
- 201 Created - Successful resource creation (POST /api/workflows)
- 200 OK - Successful read/update (GET, PUT)
- 204 No Content - Successful delete
- 400 Bad Request - Validation failure
- 403 Forbidden - Authorization failure (wrong role)
- 404 Not Found - Resource not found
- 500 Internal Server Error - Unexpected errors

**Example Controller Structure:**
```java
@RestController
@RequestMapping("/api/workflows")
public class WorkflowController {
    private static final Logger log = LoggerFactory.getLogger(WorkflowController.class);
    private final WorkflowService workflowService;

    public WorkflowController(WorkflowService workflowService) {
        this.workflowService = workflowService;
    }

    @PreAuthorize("hasRole('HR_ADMIN')")
    @PostMapping
    public ResponseEntity<WorkflowInitiationResponse> initiateWorkflow(
            @Valid @RequestBody InitiateWorkflowRequest request) {
        // Implementation
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}
```

### DTO Design
[Source: docs/architecture/coding-standards.md]

**Request DTO (InitiateWorkflowRequest):**
```java
public class InitiateWorkflowRequest {
    @NotNull(message = "Template ID is required")
    private UUID templateId;

    @NotBlank(message = "Employee name is required")
    private String employeeName;

    @NotBlank(message = "Employee email is required")
    @Email(message = "Employee email must be valid")
    private String employeeEmail;

    @NotBlank(message = "Employee role is required")
    private String employeeRole;

    private Map<String, Object> customFieldValues;

    // Getters and setters (or use Lombok @Data)
}
```

**Response DTO (WorkflowInitiationResponse):**
```java
@Data
public class WorkflowInitiationResponse {
    private UUID workflowInstanceId;
    private String employeeName;
    private WorkflowStatus status;
    private Integer totalTasksCreated;
    private Integer tasksAssigned;
    private LocalDateTime initiatedAt;
}
```

**Key Points:**
- Request DTOs: Use validation annotations, no Lombok (explicit validation messages)
- Response DTOs: Use Lombok @Data for brevity
- Never expose entities directly in API responses
- Map service results to response DTOs in controller

### Data Models Referenced
[Source: docs/architecture/data-models.md]

**WorkflowInstance Entity:**
- Primary key: UUID id
- Foreign key: UUID templateId (WorkflowTemplate)
- Employee details: String employeeName, String employeeEmail, String employeeRole
- Status: Enum (INITIATED, IN_PROGRESS, BLOCKED, COMPLETED)
- Timestamps: LocalDateTime initiatedAt, LocalDateTime completedAt (nullable)
- Custom data: Map<String, Object> customFieldValues (stored as JSONB)
- Audit: UUID initiatedBy (User), LocalDateTime createdAt, LocalDateTime updatedAt

**WorkflowStatus Enum:**
- INITIATED - Workflow created, no tasks assigned yet
- IN_PROGRESS - At least one task assigned
- BLOCKED - Workflow has blocking issues
- COMPLETED - All visible tasks completed

### Error Handling
[Source: docs/architecture/error-handling-strategy.md]

**Custom Exceptions:**
- `ResourceNotFoundException` - Template not found (404)
- `ValidationException` - Validation failures (400)
- `UnauthorizedException` - No authenticated user (401)

**Exception Flow:**
1. Controller calls service method
2. Service throws specific exception (e.g., ValidationException)
3. GlobalExceptionHandler catches exception
4. GlobalExceptionHandler returns appropriate HTTP status with error details

**Error Messages:**
- "Workflow template with ID {id} not found"
- "Workflow template with ID {id} is not active"
- "Required custom field '{fieldName}' not provided"
- "Employee email must be valid"

**Logging:**
- ERROR level: Exceptions thrown
- WARN level: Validation failures
- INFO level: Successful workflow initiations
- DEBUG level: Request/response details

### File Locations
[Source: docs/architecture/source-tree.md]

**New Files to Create:**
```
backend/src/
├── main/java/com/magnab/employeelifecycle/
│   ├── controller/
│   │   └── WorkflowController.java             # CREATE - REST controller
│   ├── dto/
│   │   ├── request/
│   │   │   └── InitiateWorkflowRequest.java     # CREATE - Request DTO
│   │   └── response/
│   │       └── WorkflowInitiationResponse.java  # CREATE - Response DTO
└── test/java/com/magnab/employeelifecycle/
    └── controller/
        ├── WorkflowControllerTest.java          # CREATE - Unit tests
        └── WorkflowControllerIntegrationTest.java # CREATE - Integration tests
```

**Existing Files to Reference (DO NOT MODIFY):**
- `service/WorkflowService.java` - Has createWorkflowInstance() and assignTasksForWorkflow() methods
- `dto/response/WorkflowCreationResult.java` - DTO returned by createWorkflowInstance()
- `dto/response/TaskAssignmentResult.java` - DTO returned by assignTasksForWorkflow()
- `entity/WorkflowInstance.java` - Entity model
- `enums/WorkflowStatus.java` - Status enum
- `exception/ResourceNotFoundException.java` - Exception for not found errors
- `exception/ValidationException.java` - Exception for validation errors
- `exception/GlobalExceptionHandler.java` - Centralized exception handling

## Testing

### Testing Approach for This Story
[Source: docs/architecture/test-strategy.md]

**Unit Tests (JUnit 5 + Mockito):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/controller/WorkflowControllerTest.java`
- Use @ExtendWith(MockitoExtension.class)
- Mock WorkflowService with @Mock
- Inject WorkflowController with @InjectMocks
- Coverage goal: 80% for controller layer

**Test Scenarios:**
1. Valid request with HR_ADMIN role → 201 Created with correct response
2. Valid request with non-HR_ADMIN role → 403 Forbidden
3. Invalid request (missing required fields) → 400 Bad Request
4. Template not found → 404 Not Found (service throws ResourceNotFoundException)
5. Validation failure → 400 Bad Request (service throws ValidationException)
6. Service methods called with correct parameters
7. Response DTO populated correctly from service results

**Integration Tests (TestContainers):**
- Test file: `backend/src/test/java/com/magnab/employeelifecycle/controller/WorkflowControllerIntegrationTest.java`
- Use @SpringBootTest and @Testcontainers
- Real PostgreSQL 17-alpine container
- Test full request-to-database flow
- Verify database state after workflow creation
- Test security (actual Spring Security context)
- Test transaction rollback on failure

**Example Unit Test Structure:**
```java
@ExtendWith(MockitoExtension.class)
class WorkflowControllerTest {
    @Mock private WorkflowService workflowService;
    @InjectMocks private WorkflowController workflowController;

    @Test
    void initiateWorkflow_ValidRequest_Returns201Created() {
        // Arrange: Mock service methods to return success results
        WorkflowCreationResult creationResult = new WorkflowCreationResult(
            UUID.randomUUID(), 15, 15
        );
        when(workflowService.createWorkflowInstance(any(), any(), any(), any()))
            .thenReturn(creationResult);

        List<TaskAssignmentResult> assignmentResults = List.of(
            new TaskAssignmentResult(UUID.randomUUID(), UUID.randomUUID(),
                "user@example.com", "Task 1", LocalDateTime.now())
        );
        when(workflowService.assignTasksForWorkflow(any()))
            .thenReturn(assignmentResults);

        InitiateWorkflowRequest request = new InitiateWorkflowRequest();
        request.setTemplateId(UUID.randomUUID());
        request.setEmployeeName("John Doe");
        request.setEmployeeEmail("john.doe@company.com");
        request.setEmployeeRole("Software Engineer");
        request.setCustomFieldValues(Map.of("startDate", "2025-02-01"));

        // Act: Call controller method
        ResponseEntity<WorkflowInitiationResponse> response =
            workflowController.initiateWorkflow(request);

        // Assert: Verify 201 status and response details
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("John Doe", response.getBody().getEmployeeName());
        assertEquals(15, response.getBody().getTotalTasksCreated());
        assertEquals(1, response.getBody().getTasksAssigned());
    }

    @Test
    @WithMockUser(roles = "LINE_MANAGER")
    void initiateWorkflow_AsNonHRAdmin_Returns403Forbidden() {
        // Test that @PreAuthorize blocks non-HR_ADMIN users
    }
}
```

**Coverage Verification:**
- Run: `mvn test jacoco:report`
- Check: `target/site/jacoco/index.html`
- Goal: 80% coverage for WorkflowController class

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-31 | 1.1 | Story validated and approved. Comprehensive validation completed: template compliance verified, all 10 ACs covered, security implementation comprehensive, anti-hallucination verification passed, implementation readiness confirmed (10/10 score). Status updated from Draft to Approved. | Sarah (Product Owner) |
| 2025-10-31 | 1.0 | Story created from Epic 3 with complete API endpoint specification. Includes REST controller implementation, request/response DTOs, role-based authorization, comprehensive validation, OpenAPI documentation, and full unit and integration testing requirements. Integrates with Story 3.2 (createWorkflowInstance) and Story 3.3 (assignTasksForWorkflow) service methods. | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by development agent_

### Debug Log References
_To be populated by development agent_

### Completion Notes
_To be populated by development agent_

### File List
_To be populated by development agent_

## QA Results
_To be populated by QA agent after story completion_
